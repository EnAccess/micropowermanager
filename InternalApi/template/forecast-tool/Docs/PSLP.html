<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 8.0.1" />
    <title>PSLP API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>


<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="index.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;
                            Module Index
                        </a>


                        <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                               pattern=".+" required>



                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="function" href="#calc_fast_PSLP">calc_fast_PSLP</a>
            </li>
            <li>
                    <a class="class" href="#PersonalizedStandardizedLoadProfile">PersonalizedStandardizedLoadProfile</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile.__init__">PersonalizedStandardizedLoadProfile</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile.get_season_info">get_season_info</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile.check_for_christmas_new_year">check_for_christmas_new_year</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile.check_if_vacation">check_if_vacation</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile.get_day_info">get_day_info</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile.classification_day">classification_day</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile.sort_data_into_profile_cache">sort_data_into_profile_cache</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile.preprocess_new_data">preprocess_new_data</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile.round_up">round_up</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile.get_previous_profile">get_previous_profile</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile.forecast">forecast</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#PersonalizedStandardizedLoadProfile_variable_length">PersonalizedStandardizedLoadProfile_variable_length</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile_variable_length.__init__">PersonalizedStandardizedLoadProfile_variable_length</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile_variable_length.get_day_info">get_day_info</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile_variable_length.classification_day">classification_day</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile_variable_length.sort_data_into_profile_cache">sort_data_into_profile_cache</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile_variable_length.preprocess_new_data">preprocess_new_data</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile_variable_length.round_up">round_up</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile_variable_length.forecast_standard">forecast_standard</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile_variable_length.forecast_fixed_recency">forecast_fixed_recency</a>
                        </li>
                        <li>
                                <a class="function" href="#PersonalizedStandardizedLoadProfile_variable_length.forecast">forecast</a>
                        </li>
                </ul>

            </li>
    </ul>



                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
PSLP    </h1>

                
                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">module_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;Forecasting-Tool.PSLP&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">calc_fast_PSLP</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pslp_window</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function</span>

<span class="sd">        Fast PSLP for Load Forecasting AI</span>

<span class="sd">    Parameter</span>

<span class="sd">        data : pd.DataFrame</span>
<span class="sd">            measured data</span>

<span class="sd">        pslp_window : int</span>
<span class="sd">            number of days to look back</span>


<span class="sd">        Return</span>

<span class="sd">            pslp</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pslp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="c1"># pslp_std = np.zeros((data.shape[0], data.shape[1]))</span>
    <span class="n">pslp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pslp_window</span><span class="p">:</span>
            <span class="n">pslp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pslp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">pslp_window</span><span class="p">:</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># pslp_std[i-pslp_window,:]= np.std(data[i-pslp_window:i,:,4], axis=0)</span>

    <span class="k">return</span> <span class="n">pslp</span>  <span class="c1"># , pslp_std</span>


<span class="k">class</span> <span class="nc">PersonalizedStandardizedLoadProfile</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function</span>

<span class="sd">        A class to calculate the Personalized Standardized Load Profile.</span>

<span class="sd">    Principle</span>

<span class="sd">        Personalized Standardized Load Profiles or short PSLP is one simple statistical approach to</span>
<span class="sd">        forecast future loads based on historical loads. The approach is a further development of the</span>
<span class="sd">        standardized load profiles which were derived by “Verband der Elektrizitätswirtschaft e.V.”</span>
<span class="sd">        (short: VDEW). The original profiles were derived by using measurements of 1209 different buildings</span>
<span class="sd">        but with the uprising implementation of smart meters the basic rules were adopted and measured</span>
<span class="sd">        data is used to derive suitable profiles for forecasting.</span>

<span class="sd">        In the basic approach there are 11 profiles derived from the measured data. These are divided by</span>
<span class="sd">        type of day (weekdays, Saturday, Sunday/vacation) and by season (transition, winter and summer).</span>

<span class="sd">        Usually public holidays are treated as a Sunday because load patterns are more equal to that then</span>
<span class="sd">        to a usual business day. Christmas and New Year’s Day are an exception from that rule because these</span>
<span class="sd">        days are treated as a Saturday if they are not on a Sunday.</span>

<span class="sd">        During preparation of the profiles measured data are sorted into the aforementioned categories.</span>
<span class="sd">        Then the profiles are calculated using the mean value of every point of time of time in the</span>
<span class="sd">        profiles.</span>

<span class="sd">        For the use in Mini-Grids the basic idea is used to generate a profile out of the measured data but</span>
<span class="sd">        the approach is further adapted to the findings in the data of the Mini-Grid. In the data no weekly</span>
<span class="sd">        seasonality was found and every day looked more like the previous day. Therefore, this</span>
<span class="sd">        differentiation was omitted. Also, no clear annual effects of lower and higher loads were</span>
<span class="sd">        determined. Because of that the differentiation between seasons was also dropped. This leaves the</span>
<span class="sd">        idea of averaging measurements of recent days to form a load profile behind. This, by any means,</span>
<span class="sd">        does not mean that this approach is suitable for all Mini-Grids as this were the results of</span>
<span class="sd">        research conducted by now.</span>

<span class="sd">    Attributes</span>

<span class="sd">        target_column : str</span>
<span class="sd">            name of column to predict</span>

<span class="sd">        holiday_times : list</span>
<span class="sd">            can be filled then it is checked if a date is holiday. This is currently not implemented</span>
<span class="sd">            as vacations were not found in measurements.</span>

<span class="sd">        data_frequency : str</span>
<span class="sd">            Frequency in which prediction should be done and incoming data is</span>

<span class="sd">        cache_dict : dict</span>
<span class="sd">            storage for classified data</span>

<span class="sd">        last_processed_timestep : pd.datetime</span>
<span class="sd">            last timestep classified</span>

<span class="sd">    Methods</span>

<span class="sd">        __init_dicts()</span>
<span class="sd">            inits storage dicts</span>

<span class="sd">        __vacation_dates()</span>
<span class="sd">            get vacation dates</span>

<span class="sd">        get_season_info()</span>
<span class="sd">            info on which season data is in</span>

<span class="sd">        check_for_christmas_new_year()</span>
<span class="sd">            checks if date is christmas (currently set to always false)</span>

<span class="sd">        check_if_vacation()</span>
<span class="sd">            checks if date is vacation (currently set to always false)</span>

<span class="sd">        get_day_info()</span>
<span class="sd">            if day is weekday or Saturday or Sunday (currently set to always week)</span>

<span class="sd">        classification_day()</span>
<span class="sd">            gather all info to classify day</span>
<span class="sd">            uses get_season_info() and get_day_info()</span>

<span class="sd">        sort_data_into_profile_cache()</span>
<span class="sd">            sorts data into cache storages</span>

<span class="sd">        preprocess_new_data()</span>
<span class="sd">            preprocesses new incoming data into classes</span>

<span class="sd">        round_up()</span>
<span class="sd">            rounds up to next timestep</span>

<span class="sd">        get_previous_profile()</span>
<span class="sd">            if correct profile is not available it uses previous one</span>

<span class="sd">        forecast()</span>
<span class="sd">            forecasts future loads</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attributes</span>

<span class="sd">            target_column : str</span>
<span class="sd">                name of column to predict</span>

<span class="sd">            holiday_times : list</span>
<span class="sd">                can be filled then it is checked if a date is holiday. This is currently not implemented</span>
<span class="sd">                as vacations were not found in measurements.</span>

<span class="sd">            data_frequency : str</span>
<span class="sd">                Frequency in which prediction should be done and incoming data is</span>

<span class="sd">            cache_dict : dict</span>
<span class="sd">                storage for classified data</span>

<span class="sd">            last_processed_timestep : pd.datetime</span>
<span class="sd">                last timestep classified</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_column</span> <span class="o">=</span> <span class="n">target_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holiday_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vacation_dates</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span> <span class="o">=</span> <span class="s1">&#39;15Min&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__init_dicts</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init_dicts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># initializes data storages</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;00:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;23:59:59&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span><span class="o">.</span><span class="n">time</span>
        <span class="n">dict_with_empty_profiles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">dict_with_empty_profiles</span><span class="p">[</span><span class="s1">&#39;ww&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>  <span class="c1"># weeks in winter</span>
        <span class="n">dict_with_empty_profiles</span><span class="p">[</span><span class="s1">&#39;sw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>  <span class="c1"># weeks in summer</span>
        <span class="n">dict_with_empty_profiles</span><span class="p">[</span><span class="s1">&#39;tw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>  <span class="c1"># weeks in transition</span>
        <span class="k">return</span> <span class="n">dict_with_empty_profiles</span>

    <span class="k">def</span> <span class="nf">__vacation_dates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># add information on vacation dates</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">get_season_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">year</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            extract seasonal info from timestamp</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>

<span class="sd">        Return</span>

<span class="sd">            season in which timestamp is</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-01-01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
                <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-03-20&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-11-01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
            <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-12-31&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">():</span>
            <span class="n">season</span> <span class="o">=</span> <span class="s1">&#39;w&#39;</span>  <span class="c1"># winter</span>
        <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-03-21&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
                <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-05-14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
            <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-09-15&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-10-31&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">():</span>
            <span class="n">season</span> <span class="o">=</span> <span class="s1">&#39;t&#39;</span>  <span class="c1"># transition</span>
        <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-05-15&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
                <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-09-14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">():</span>
            <span class="n">season</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>  <span class="c1"># summer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Undefined Date&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">season</span>

    <span class="k">def</span> <span class="nf">check_for_christmas_new_year</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">dayofweek</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            checks if date is christmas</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>

<span class="sd">            dayofweek : str</span>



<span class="sd">        Return</span>

<span class="sd">            deactivated -&gt; returns always 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">check_if_vacation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            checks if date is christmas</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            deactivated -&gt; returns always 0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">get_day_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            classify if day is weekday (w), saturday (sa) or sunday (su)</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            deactivated -&gt; returns always w</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">day_info</span> <span class="o">=</span> <span class="s1">&#39;w&#39;</span>
        <span class="k">return</span> <span class="n">day_info</span>

    <span class="k">def</span> <span class="nf">classification_day</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            find season and day type</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>


<span class="sd">        Return</span>

<span class="sd">            season and day_info : str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>
        <span class="n">season</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_season_info</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span>
        <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_day_info</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">season</span><span class="p">,</span> <span class="n">day_info</span>

    <span class="k">def</span> <span class="nf">sort_data_into_profile_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="n">data_on_date</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            sort day into cache to be able to make profiles</span>

<span class="sd">        Parameter</span>

<span class="sd">            profile : pd.DataFrame</span>
<span class="sd">                profile to sort data in</span>

<span class="sd">            data_on_date : pd.DataFrame</span>
<span class="sd">                data measured on date</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>


<span class="sd">        Return</span>

<span class="sd">            Return is stored in class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">profile_data_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span>
        <span class="n">data_on_date</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_on_date</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
        <span class="n">profile_data_cache</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_on_date</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_on_date</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_column</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">preprocess_new_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incoming_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            process new data into data cache</span>

<span class="sd">        Parameter</span>

<span class="sd">            incoming_data : pd.DataFrame</span>
<span class="sd">                new measured data</span>


<span class="sd">        Return</span>

<span class="sd">            Return is stored in class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">last_timestamp</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">()</span>
        <span class="c1"># check if incoming_data contains new data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="n">last_timestamp</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">incoming_data</span><span class="o">.</span><span class="n">index</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="n">last_timestamp</span>
        <span class="c1"># extract time information</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">date</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">time</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="c1"># sort data</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">data_on_date</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span>
            <span class="n">season</span><span class="p">,</span> <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">profile_number</span> <span class="o">=</span> <span class="n">season</span> <span class="o">+</span> <span class="n">day_info</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort_data_into_profile_cache</span><span class="p">(</span><span class="n">profile_number</span><span class="p">,</span> <span class="n">data_on_date</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">round_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            rounded time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_now_round</span> <span class="o">=</span> <span class="n">time_now</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_now_round</span> <span class="o">&lt;</span> <span class="n">time_now</span><span class="p">:</span>
            <span class="n">time_now_round</span> <span class="o">=</span> <span class="n">time_now_round</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_now_round</span>

    <span class="k">def</span> <span class="nf">get_previous_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">season</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            if there is no data in the profile for current season, use values of the last season as a guess</span>

<span class="sd">        Parameter</span>

<span class="sd">            season : str</span>
<span class="sd">                classified season</span>

<span class="sd">            date : str</span>
<span class="sd">                date of measurement</span>


<span class="sd">        Return</span>

<span class="sd">            name of previous profile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">year</span>
        <span class="k">if</span> <span class="n">season</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span> <span class="ow">or</span> <span class="n">season</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;t&#39;</span>
        <span class="k">elif</span> <span class="n">season</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-05-15&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-09-14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">():</span>
                <span class="k">return</span> <span class="s1">&#39;s&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;w&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Previous Season not found!&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">forecast_horizon</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            Forecasting</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>

<span class="sd">            forecast_horizon : str</span>
<span class="sd">                horizon length on which predictions should be made</span>


<span class="sd">        Return</span>

<span class="sd">            forecast as pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># round up time</span>
        <span class="n">time_now_rounded_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_up</span><span class="p">(</span><span class="n">time_now</span><span class="p">)</span>
        <span class="c1"># get index over forecast horizon</span>
        <span class="n">forecast_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">time_now_rounded_up</span><span class="p">,</span>
                                       <span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_now_rounded_up</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">forecast_horizon</span><span class="p">),</span>
                                       <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="c1"># initialize dataframe to store forecast</span>
        <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">forecast_index</span><span class="p">)</span>
        <span class="c1"># extract time info</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span>
        <span class="c1"># get unique dates</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="c1"># make forecasts</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="c1"># classify days to do forecast</span>
            <span class="n">season</span><span class="p">,</span> <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">day_character</span> <span class="o">=</span> <span class="n">season</span> <span class="o">+</span> <span class="n">day_info</span>
            <span class="c1"># get profile data</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>
            <span class="c1"># calculate profile</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># if profile is not available use previous</span>
            <span class="k">if</span> <span class="n">profile</span><span class="o">.</span><span class="n">empty</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="o">.</span><span class="n">dropna</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">season</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_previous_profile</span><span class="p">(</span><span class="n">season</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
                <span class="n">day_character</span> <span class="o">=</span> <span class="n">season</span> <span class="o">+</span> <span class="n">day_info</span>
                <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>
                <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># predict</span>
            <span class="n">data_for_day</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
            <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;forecast&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">PersonalizedStandardizedLoadProfile_variable_length</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Function</span>

<span class="sd">         A class to calculate the Personalized Standardized Load Profile.</span>

<span class="sd">     Principle</span>

<span class="sd">         Personalized Standardized Load Profiles or short PSLP is one simple statistical approach to</span>
<span class="sd">         forecast future loads based on historical loads. The approach is a further development of the</span>
<span class="sd">         standardized load profiles which were derived by “Verband der Elektrizitätswirtschaft e.V.”</span>
<span class="sd">         (short: VDEW). The original profiles were derived by using measurements of 1209 different buildings</span>
<span class="sd">         but with the uprising implementation of smart meters the basic rules were adopted and measured</span>
<span class="sd">         data is used to derive suitable profiles for forecasting.</span>

<span class="sd">         In the basic approach there are 11 profiles derived from the measured data. These are divided by</span>
<span class="sd">         type of day (weekdays, Saturday, Sunday/vacation) and by season (transition, winter and summer).</span>

<span class="sd">         Usually public holidays are treated as a Sunday because load patterns are more equal to that then</span>
<span class="sd">         to a usual business day. Christmas and New Year’s Day are an exception from that rule because these</span>
<span class="sd">         days are treated as a Saturday if they are not on a Sunday.</span>

<span class="sd">         During preparation of the profiles measured data are sorted into the aforementioned categories.</span>
<span class="sd">         Then the profiles are calculated using the mean value of every point of time of time in the</span>
<span class="sd">         profiles.</span>

<span class="sd">         For the use in Mini-Grids the basic idea is used to generate a profile out of the measured data but</span>
<span class="sd">         the approach is further adapted to the findings in the data of the Mini-Grid. In the data no weekly</span>
<span class="sd">         seasonality was found and every day looked more like the previous day. Therefore, this</span>
<span class="sd">         differentiation was omitted. Also, no clear annual effects of lower and higher loads were</span>
<span class="sd">         determined. Because of that the differentiation between seasons was also dropped. This leaves the</span>
<span class="sd">         idea of averaging measurements of recent days to form a load profile behind. This, by any means,</span>
<span class="sd">         does not mean that this approach is suitable for all Mini-Grids as this were the results of</span>
<span class="sd">         research conducted by now.</span>

<span class="sd">         This class has an extension compared to the normal PSLP which is that it tries to estimate best</span>
<span class="sd">         length of window size (starting at 1 Day going back to 31Days). This can increase forecast</span>
<span class="sd">         accuracy when days are more or less fluctuating without a specific pattern.</span>

<span class="sd">     Attributes</span>

<span class="sd">         target_column : str</span>
<span class="sd">             name of column to predict</span>

<span class="sd">         holiday_times : list</span>
<span class="sd">             can be filled then it is checked if a date is holiday. This is currently not implemented</span>
<span class="sd">             as vacations were not found in measurements.</span>

<span class="sd">         data_frequency : str</span>
<span class="sd">             Frequency in which prediction should be done and incoming data is</span>

<span class="sd">         cache_dict : dict</span>
<span class="sd">             storage for classified data</span>

<span class="sd">         last_processed_timestep : pd.datetime</span>
<span class="sd">             last timestep classified</span>

<span class="sd">     Methods</span>

<span class="sd">         __init_dicts()</span>
<span class="sd">             inits storage dicts</span>

<span class="sd">         __vacation_dates()</span>
<span class="sd">             get vacation dates</span>

<span class="sd">         get_season_info()</span>
<span class="sd">             info on which season data is in</span>

<span class="sd">         check_for_christmas_new_year()</span>
<span class="sd">             checks if date is christmas (currently set to always false)</span>

<span class="sd">         check_if_vacation()</span>
<span class="sd">             checks if date is vacation (currently set to always false)</span>

<span class="sd">         get_day_info()</span>
<span class="sd">             if day is weekday or Saturday or Sunday (currently set to always week)</span>

<span class="sd">         classification_day()</span>
<span class="sd">             gather all info to classify day</span>
<span class="sd">             uses get_season_info() and get_day_info()</span>

<span class="sd">         sort_data_into_profile_cache()</span>
<span class="sd">             sorts data into cache storages</span>

<span class="sd">         preprocess_new_data()</span>
<span class="sd">             preprocesses new incoming data into classes</span>

<span class="sd">         round_up()</span>
<span class="sd">             rounds up to next timestep</span>

<span class="sd">         get_previous_profile()</span>
<span class="sd">             if correct profile is not available it uses previous one</span>

<span class="sd">         forecast()</span>
<span class="sd">             forecasts future loads</span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_column</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_column</span> <span class="o">=</span> <span class="n">target_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_training</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span> <span class="o">=</span> <span class="s1">&#39;15Min&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__init_dicts</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init_dicts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># initializes data storages</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;00:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;23:59:59&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span><span class="o">.</span><span class="n">time</span>
        <span class="n">dict_with_empty_profiles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">dict_with_empty_profiles</span><span class="p">[</span><span class="s1">&#39;profile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>  <span class="c1"># weeks in winter</span>
        <span class="k">return</span> <span class="n">dict_with_empty_profiles</span>

    <span class="k">def</span> <span class="nf">get_day_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            classify if day is weekday (w), saturday (sa) or sunday (su)</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            deactivated -&gt; returns always w</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">day_info</span> <span class="o">=</span> <span class="s1">&#39;profile&#39;</span>
        <span class="k">return</span> <span class="n">day_info</span>

    <span class="k">def</span> <span class="nf">classification_day</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            find season and day type</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>


<span class="sd">        Return</span>

<span class="sd">            season and day_info : str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_day_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">day_info</span>

    <span class="k">def</span> <span class="nf">sort_data_into_profile_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_on_date</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            sort day into cache to be able to make profiles</span>

<span class="sd">        Parameter</span>

<span class="sd">            profile : pd.DataFrame</span>
<span class="sd">                profile to sort data in</span>

<span class="sd">            data_on_date : pd.DataFrame</span>
<span class="sd">                data measured on date</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>


<span class="sd">        Return</span>

<span class="sd">            Return is stored in class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sort day into cache to be able to make profiles</span>
        <span class="n">profile_data_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">)</span>
        <span class="n">data_on_date</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_on_date</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
        <span class="n">profile_data_cache</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_on_date</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_on_date</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_column</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">preprocess_new_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incoming_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            process new data into data cache</span>

<span class="sd">        Parameter</span>

<span class="sd">            incoming_data : pd.DataFrame</span>
<span class="sd">                new measured data</span>


<span class="sd">        Return</span>

<span class="sd">            Return is stored in class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># process new data into data cache</span>
        <span class="n">last_timestamp</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="n">last_timestamp</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">incoming_data</span><span class="o">.</span><span class="n">index</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="n">last_timestamp</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">date</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">time</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">data_on_date</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span>
            <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort_data_into_profile_cache</span><span class="p">(</span><span class="n">data_on_date</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">round_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            rounded time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)</span>
        <span class="n">time_now_round</span> <span class="o">=</span> <span class="n">time_now</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_now_round</span> <span class="o">&lt;</span> <span class="n">time_now</span><span class="p">:</span>
            <span class="n">time_now_round</span> <span class="o">=</span> <span class="n">time_now_round</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_now_round</span>

    <span class="k">def</span> <span class="nf">forecast_standard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">forecast_horizon</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            Forecasting</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>

<span class="sd">            forecast_horizon : str</span>
<span class="sd">                horizon length on which predictions should be made</span>


<span class="sd">        Return</span>

<span class="sd">            forecast as pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># load forecasting part</span>
        <span class="n">time_now_rounded_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_up</span><span class="p">(</span><span class="n">time_now</span><span class="p">)</span>
        <span class="n">forecast_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">time_now_rounded_up</span><span class="p">,</span>
                                       <span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_now_rounded_up</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">forecast_horizon</span><span class="p">),</span>
                                       <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">forecast_index</span><span class="p">)</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">day_character</span> <span class="o">=</span> <span class="n">day_info</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">data_for_day</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
            <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;forecast&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">forecast_fixed_recency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">forecast_horizon</span><span class="p">,</span> <span class="n">fixed_recency</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            Forecasting with a pre set recency</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>

<span class="sd">            forecast_horizon : str</span>
<span class="sd">                horizon length on which predictions should be made</span>

<span class="sd">            fixed_recency : int</span>
<span class="sd">                days of data used for calculating PSLP</span>


<span class="sd">        Return</span>

<span class="sd">            forecast as pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># load forecasting part</span>
        <span class="n">time_now_rounded_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_up</span><span class="p">(</span><span class="n">time_now</span><span class="p">)</span>
        <span class="n">forecast_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">time_now_rounded_up</span><span class="p">,</span>
                                       <span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_now_rounded_up</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">forecast_horizon</span><span class="p">),</span>
                                       <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">forecast_index</span><span class="p">)</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">day_character</span> <span class="o">=</span> <span class="n">day_info</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>

            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">fixed_recency</span><span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">data_for_day</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
            <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;forecast&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__test_recency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testing_length</span><span class="p">):</span>
        <span class="n">best_recency</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">recency</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">30</span><span class="p">):</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">)</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">recency</span><span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">profile_sum</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">tests</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">testing_length</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">tests</span> <span class="o">=</span> <span class="n">tests</span> <span class="o">-</span> <span class="n">profile_sum</span>
            <span class="n">mean_error</span> <span class="o">=</span> <span class="n">tests</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">best_recency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">best_recency</span> <span class="o">=</span> <span class="n">recency</span>
            <span class="k">if</span> <span class="n">best_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">best_error</span> <span class="o">=</span> <span class="n">mean_error</span>
            <span class="k">if</span> <span class="n">best_error</span> <span class="o">&gt;</span> <span class="n">mean_error</span><span class="p">:</span>
                <span class="n">best_recency</span> <span class="o">=</span> <span class="n">recency</span>
                <span class="n">best_error</span> <span class="o">=</span> <span class="n">mean_error</span>
        <span class="k">return</span> <span class="n">best_recency</span>

    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">forecast_horizon</span><span class="p">,</span> <span class="n">testing_length</span><span class="o">=</span><span class="mi">31</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            Forecasting with variable length recency</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>

<span class="sd">            forecast_horizon : str</span>
<span class="sd">                horizon length on which predictions should be made</span>

<span class="sd">            testing_length : int</span>
<span class="sd">                sets maximum days to test to find best recency</span>

<span class="sd">        Return</span>

<span class="sd">            forecast as pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># load forecasting part</span>
        <span class="n">time_now_rounded_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_up</span><span class="p">(</span><span class="n">time_now</span><span class="p">)</span>
        <span class="n">forecast_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">time_now_rounded_up</span><span class="p">,</span>
                                       <span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_now_rounded_up</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">forecast_horizon</span><span class="p">),</span>
                                       <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">forecast_index</span><span class="p">)</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="n">number_of_days</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">number_of_days</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">recency</span> <span class="o">=</span> <span class="n">number_of_days</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__test_recency</span><span class="p">(</span><span class="n">testing_length</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">day_character</span> <span class="o">=</span> <span class="n">day_info</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">recency</span><span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">data_for_day</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
            <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;forecast&#39;</span><span class="p">]</span>
        <span class="n">module_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;PSLP: recency set to: </span><span class="si">{</span><span class="n">recency</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">])</span>
</pre></div>

        </details>

            </section>
                <section id="calc_fast_PSLP">
                            <div class="attr function"><a class="headerlink" href="#calc_fast_PSLP">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">calc_fast_PSLP</span><span class="signature">(data, pslp_window)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">calc_fast_PSLP</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pslp_window</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function</span>

<span class="sd">        Fast PSLP for Load Forecasting AI</span>

<span class="sd">    Parameter</span>

<span class="sd">        data : pd.DataFrame</span>
<span class="sd">            measured data</span>

<span class="sd">        pslp_window : int</span>
<span class="sd">            number of days to look back</span>


<span class="sd">        Return</span>

<span class="sd">            pslp</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pslp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="c1"># pslp_std = np.zeros((data.shape[0], data.shape[1]))</span>
    <span class="n">pslp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pslp_window</span><span class="p">:</span>
            <span class="n">pslp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pslp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">pslp_window</span><span class="p">:</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># pslp_std[i-pslp_window,:]= np.std(data[i-pslp_window:i,:,4], axis=0)</span>

    <span class="k">return</span> <span class="n">pslp</span>  <span class="c1"># , pslp_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>Fast PSLP for Load Forecasting AI
</code></pre>

<p>Parameter</p>

<pre><code>data : pd.DataFrame
    measured data

pslp_window : int
    number of days to look back


Return

    pslp
</code></pre>
</div>


                </section>
                <section id="PersonalizedStandardizedLoadProfile">
                                <div class="attr class">
        <a class="headerlink" href="#PersonalizedStandardizedLoadProfile">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">PersonalizedStandardizedLoadProfile</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PersonalizedStandardizedLoadProfile</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function</span>

<span class="sd">        A class to calculate the Personalized Standardized Load Profile.</span>

<span class="sd">    Principle</span>

<span class="sd">        Personalized Standardized Load Profiles or short PSLP is one simple statistical approach to</span>
<span class="sd">        forecast future loads based on historical loads. The approach is a further development of the</span>
<span class="sd">        standardized load profiles which were derived by “Verband der Elektrizitätswirtschaft e.V.”</span>
<span class="sd">        (short: VDEW). The original profiles were derived by using measurements of 1209 different buildings</span>
<span class="sd">        but with the uprising implementation of smart meters the basic rules were adopted and measured</span>
<span class="sd">        data is used to derive suitable profiles for forecasting.</span>

<span class="sd">        In the basic approach there are 11 profiles derived from the measured data. These are divided by</span>
<span class="sd">        type of day (weekdays, Saturday, Sunday/vacation) and by season (transition, winter and summer).</span>

<span class="sd">        Usually public holidays are treated as a Sunday because load patterns are more equal to that then</span>
<span class="sd">        to a usual business day. Christmas and New Year’s Day are an exception from that rule because these</span>
<span class="sd">        days are treated as a Saturday if they are not on a Sunday.</span>

<span class="sd">        During preparation of the profiles measured data are sorted into the aforementioned categories.</span>
<span class="sd">        Then the profiles are calculated using the mean value of every point of time of time in the</span>
<span class="sd">        profiles.</span>

<span class="sd">        For the use in Mini-Grids the basic idea is used to generate a profile out of the measured data but</span>
<span class="sd">        the approach is further adapted to the findings in the data of the Mini-Grid. In the data no weekly</span>
<span class="sd">        seasonality was found and every day looked more like the previous day. Therefore, this</span>
<span class="sd">        differentiation was omitted. Also, no clear annual effects of lower and higher loads were</span>
<span class="sd">        determined. Because of that the differentiation between seasons was also dropped. This leaves the</span>
<span class="sd">        idea of averaging measurements of recent days to form a load profile behind. This, by any means,</span>
<span class="sd">        does not mean that this approach is suitable for all Mini-Grids as this were the results of</span>
<span class="sd">        research conducted by now.</span>

<span class="sd">    Attributes</span>

<span class="sd">        target_column : str</span>
<span class="sd">            name of column to predict</span>

<span class="sd">        holiday_times : list</span>
<span class="sd">            can be filled then it is checked if a date is holiday. This is currently not implemented</span>
<span class="sd">            as vacations were not found in measurements.</span>

<span class="sd">        data_frequency : str</span>
<span class="sd">            Frequency in which prediction should be done and incoming data is</span>

<span class="sd">        cache_dict : dict</span>
<span class="sd">            storage for classified data</span>

<span class="sd">        last_processed_timestep : pd.datetime</span>
<span class="sd">            last timestep classified</span>

<span class="sd">    Methods</span>

<span class="sd">        __init_dicts()</span>
<span class="sd">            inits storage dicts</span>

<span class="sd">        __vacation_dates()</span>
<span class="sd">            get vacation dates</span>

<span class="sd">        get_season_info()</span>
<span class="sd">            info on which season data is in</span>

<span class="sd">        check_for_christmas_new_year()</span>
<span class="sd">            checks if date is christmas (currently set to always false)</span>

<span class="sd">        check_if_vacation()</span>
<span class="sd">            checks if date is vacation (currently set to always false)</span>

<span class="sd">        get_day_info()</span>
<span class="sd">            if day is weekday or Saturday or Sunday (currently set to always week)</span>

<span class="sd">        classification_day()</span>
<span class="sd">            gather all info to classify day</span>
<span class="sd">            uses get_season_info() and get_day_info()</span>

<span class="sd">        sort_data_into_profile_cache()</span>
<span class="sd">            sorts data into cache storages</span>

<span class="sd">        preprocess_new_data()</span>
<span class="sd">            preprocesses new incoming data into classes</span>

<span class="sd">        round_up()</span>
<span class="sd">            rounds up to next timestep</span>

<span class="sd">        get_previous_profile()</span>
<span class="sd">            if correct profile is not available it uses previous one</span>

<span class="sd">        forecast()</span>
<span class="sd">            forecasts future loads</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attributes</span>

<span class="sd">            target_column : str</span>
<span class="sd">                name of column to predict</span>

<span class="sd">            holiday_times : list</span>
<span class="sd">                can be filled then it is checked if a date is holiday. This is currently not implemented</span>
<span class="sd">                as vacations were not found in measurements.</span>

<span class="sd">            data_frequency : str</span>
<span class="sd">                Frequency in which prediction should be done and incoming data is</span>

<span class="sd">            cache_dict : dict</span>
<span class="sd">                storage for classified data</span>

<span class="sd">            last_processed_timestep : pd.datetime</span>
<span class="sd">                last timestep classified</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_column</span> <span class="o">=</span> <span class="n">target_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holiday_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vacation_dates</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span> <span class="o">=</span> <span class="s1">&#39;15Min&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__init_dicts</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init_dicts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># initializes data storages</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;00:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;23:59:59&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span><span class="o">.</span><span class="n">time</span>
        <span class="n">dict_with_empty_profiles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">dict_with_empty_profiles</span><span class="p">[</span><span class="s1">&#39;ww&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>  <span class="c1"># weeks in winter</span>
        <span class="n">dict_with_empty_profiles</span><span class="p">[</span><span class="s1">&#39;sw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>  <span class="c1"># weeks in summer</span>
        <span class="n">dict_with_empty_profiles</span><span class="p">[</span><span class="s1">&#39;tw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>  <span class="c1"># weeks in transition</span>
        <span class="k">return</span> <span class="n">dict_with_empty_profiles</span>

    <span class="k">def</span> <span class="nf">__vacation_dates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># add information on vacation dates</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">get_season_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">year</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            extract seasonal info from timestamp</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>

<span class="sd">        Return</span>

<span class="sd">            season in which timestamp is</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-01-01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
                <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-03-20&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-11-01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
            <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-12-31&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">():</span>
            <span class="n">season</span> <span class="o">=</span> <span class="s1">&#39;w&#39;</span>  <span class="c1"># winter</span>
        <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-03-21&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
                <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-05-14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
            <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-09-15&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-10-31&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">():</span>
            <span class="n">season</span> <span class="o">=</span> <span class="s1">&#39;t&#39;</span>  <span class="c1"># transition</span>
        <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-05-15&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
                <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-09-14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">():</span>
            <span class="n">season</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>  <span class="c1"># summer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Undefined Date&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">season</span>

    <span class="k">def</span> <span class="nf">check_for_christmas_new_year</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">dayofweek</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            checks if date is christmas</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>

<span class="sd">            dayofweek : str</span>



<span class="sd">        Return</span>

<span class="sd">            deactivated -&gt; returns always 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">check_if_vacation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            checks if date is christmas</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            deactivated -&gt; returns always 0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">get_day_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            classify if day is weekday (w), saturday (sa) or sunday (su)</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            deactivated -&gt; returns always w</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">day_info</span> <span class="o">=</span> <span class="s1">&#39;w&#39;</span>
        <span class="k">return</span> <span class="n">day_info</span>

    <span class="k">def</span> <span class="nf">classification_day</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            find season and day type</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>


<span class="sd">        Return</span>

<span class="sd">            season and day_info : str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>
        <span class="n">season</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_season_info</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span>
        <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_day_info</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">season</span><span class="p">,</span> <span class="n">day_info</span>

    <span class="k">def</span> <span class="nf">sort_data_into_profile_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="n">data_on_date</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            sort day into cache to be able to make profiles</span>

<span class="sd">        Parameter</span>

<span class="sd">            profile : pd.DataFrame</span>
<span class="sd">                profile to sort data in</span>

<span class="sd">            data_on_date : pd.DataFrame</span>
<span class="sd">                data measured on date</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>


<span class="sd">        Return</span>

<span class="sd">            Return is stored in class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">profile_data_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span>
        <span class="n">data_on_date</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_on_date</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
        <span class="n">profile_data_cache</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_on_date</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_on_date</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_column</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">preprocess_new_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incoming_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            process new data into data cache</span>

<span class="sd">        Parameter</span>

<span class="sd">            incoming_data : pd.DataFrame</span>
<span class="sd">                new measured data</span>


<span class="sd">        Return</span>

<span class="sd">            Return is stored in class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">last_timestamp</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">()</span>
        <span class="c1"># check if incoming_data contains new data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="n">last_timestamp</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">incoming_data</span><span class="o">.</span><span class="n">index</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="n">last_timestamp</span>
        <span class="c1"># extract time information</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">date</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">time</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="c1"># sort data</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">data_on_date</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span>
            <span class="n">season</span><span class="p">,</span> <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">profile_number</span> <span class="o">=</span> <span class="n">season</span> <span class="o">+</span> <span class="n">day_info</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort_data_into_profile_cache</span><span class="p">(</span><span class="n">profile_number</span><span class="p">,</span> <span class="n">data_on_date</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">round_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            rounded time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_now_round</span> <span class="o">=</span> <span class="n">time_now</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_now_round</span> <span class="o">&lt;</span> <span class="n">time_now</span><span class="p">:</span>
            <span class="n">time_now_round</span> <span class="o">=</span> <span class="n">time_now_round</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_now_round</span>

    <span class="k">def</span> <span class="nf">get_previous_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">season</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            if there is no data in the profile for current season, use values of the last season as a guess</span>

<span class="sd">        Parameter</span>

<span class="sd">            season : str</span>
<span class="sd">                classified season</span>

<span class="sd">            date : str</span>
<span class="sd">                date of measurement</span>


<span class="sd">        Return</span>

<span class="sd">            name of previous profile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">year</span>
        <span class="k">if</span> <span class="n">season</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span> <span class="ow">or</span> <span class="n">season</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;t&#39;</span>
        <span class="k">elif</span> <span class="n">season</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-05-15&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-09-14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">():</span>
                <span class="k">return</span> <span class="s1">&#39;s&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;w&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Previous Season not found!&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">forecast_horizon</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            Forecasting</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>

<span class="sd">            forecast_horizon : str</span>
<span class="sd">                horizon length on which predictions should be made</span>


<span class="sd">        Return</span>

<span class="sd">            forecast as pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># round up time</span>
        <span class="n">time_now_rounded_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_up</span><span class="p">(</span><span class="n">time_now</span><span class="p">)</span>
        <span class="c1"># get index over forecast horizon</span>
        <span class="n">forecast_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">time_now_rounded_up</span><span class="p">,</span>
                                       <span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_now_rounded_up</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">forecast_horizon</span><span class="p">),</span>
                                       <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="c1"># initialize dataframe to store forecast</span>
        <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">forecast_index</span><span class="p">)</span>
        <span class="c1"># extract time info</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span>
        <span class="c1"># get unique dates</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="c1"># make forecasts</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="c1"># classify days to do forecast</span>
            <span class="n">season</span><span class="p">,</span> <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">day_character</span> <span class="o">=</span> <span class="n">season</span> <span class="o">+</span> <span class="n">day_info</span>
            <span class="c1"># get profile data</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>
            <span class="c1"># calculate profile</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># if profile is not available use previous</span>
            <span class="k">if</span> <span class="n">profile</span><span class="o">.</span><span class="n">empty</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="o">.</span><span class="n">dropna</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">season</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_previous_profile</span><span class="p">(</span><span class="n">season</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
                <span class="n">day_character</span> <span class="o">=</span> <span class="n">season</span> <span class="o">+</span> <span class="n">day_info</span>
                <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>
                <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># predict</span>
            <span class="n">data_for_day</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
            <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;forecast&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">])</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>A class to calculate the Personalized Standardized Load Profile.
</code></pre>

<p>Principle</p>

<pre><code>Personalized Standardized Load Profiles or short PSLP is one simple statistical approach to
forecast future loads based on historical loads. The approach is a further development of the
standardized load profiles which were derived by “Verband der Elektrizitätswirtschaft e.V.”
(short: VDEW). The original profiles were derived by using measurements of 1209 different buildings
but with the uprising implementation of smart meters the basic rules were adopted and measured
data is used to derive suitable profiles for forecasting.

In the basic approach there are 11 profiles derived from the measured data. These are divided by
type of day (weekdays, Saturday, Sunday/vacation) and by season (transition, winter and summer).

Usually public holidays are treated as a Sunday because load patterns are more equal to that then
to a usual business day. Christmas and New Year’s Day are an exception from that rule because these
days are treated as a Saturday if they are not on a Sunday.

During preparation of the profiles measured data are sorted into the aforementioned categories.
Then the profiles are calculated using the mean value of every point of time of time in the
profiles.

For the use in Mini-Grids the basic idea is used to generate a profile out of the measured data but
the approach is further adapted to the findings in the data of the Mini-Grid. In the data no weekly
seasonality was found and every day looked more like the previous day. Therefore, this
differentiation was omitted. Also, no clear annual effects of lower and higher loads were
determined. Because of that the differentiation between seasons was also dropped. This leaves the
idea of averaging measurements of recent days to form a load profile behind. This, by any means,
does not mean that this approach is suitable for all Mini-Grids as this were the results of
research conducted by now.
</code></pre>

<p>Attributes</p>

<pre><code>target_column : str
    name of column to predict

holiday_times : list
    can be filled then it is checked if a date is holiday. This is currently not implemented
    as vacations were not found in measurements.

data_frequency : str
    Frequency in which prediction should be done and incoming data is

cache_dict : dict
    storage for classified data

last_processed_timestep : pd.datetime
    last timestep classified
</code></pre>

<p>Methods</p>

<pre><code>__init_dicts()
    inits storage dicts

__vacation_dates()
    get vacation dates

get_season_info()
    info on which season data is in

check_for_christmas_new_year()
    checks if date is christmas (currently set to always false)

check_if_vacation()
    checks if date is vacation (currently set to always false)

get_day_info()
    if day is weekday or Saturday or Sunday (currently set to always week)

classification_day()
    gather all info to classify day
    uses get_season_info() and get_day_info()

sort_data_into_profile_cache()
    sorts data into cache storages

preprocess_new_data()
    preprocesses new incoming data into classes

round_up()
    rounds up to next timestep

get_previous_profile()
    if correct profile is not available it uses previous one

forecast()
    forecasts future loads
</code></pre>
</div>


                            <div id="PersonalizedStandardizedLoadProfile.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">PersonalizedStandardizedLoadProfile</span><span class="signature">(target_column)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attributes</span>

<span class="sd">            target_column : str</span>
<span class="sd">                name of column to predict</span>

<span class="sd">            holiday_times : list</span>
<span class="sd">                can be filled then it is checked if a date is holiday. This is currently not implemented</span>
<span class="sd">                as vacations were not found in measurements.</span>

<span class="sd">            data_frequency : str</span>
<span class="sd">                Frequency in which prediction should be done and incoming data is</span>

<span class="sd">            cache_dict : dict</span>
<span class="sd">                storage for classified data</span>

<span class="sd">            last_processed_timestep : pd.datetime</span>
<span class="sd">                last timestep classified</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_column</span> <span class="o">=</span> <span class="n">target_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holiday_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vacation_dates</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span> <span class="o">=</span> <span class="s1">&#39;15Min&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__init_dicts</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>Attributes</p>

<pre><code>target_column : str
    name of column to predict

holiday_times : list
    can be filled then it is checked if a date is holiday. This is currently not implemented
    as vacations were not found in measurements.

data_frequency : str
    Frequency in which prediction should be done and incoming data is

cache_dict : dict
    storage for classified data

last_processed_timestep : pd.datetime
    last timestep classified
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile.get_season_info" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile.get_season_info">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_season_info</span><span class="signature">(self, date, year)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_season_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">year</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            extract seasonal info from timestamp</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>

<span class="sd">        Return</span>

<span class="sd">            season in which timestamp is</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-01-01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
                <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-03-20&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-11-01&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
            <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-12-31&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">():</span>
            <span class="n">season</span> <span class="o">=</span> <span class="s1">&#39;w&#39;</span>  <span class="c1"># winter</span>
        <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-03-21&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
                <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-05-14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
            <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-09-15&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-10-31&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">():</span>
            <span class="n">season</span> <span class="o">=</span> <span class="s1">&#39;t&#39;</span>  <span class="c1"># transition</span>
        <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-05-15&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
                <span class="n">year</span> <span class="o">+</span> <span class="s1">&#39;-09-14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">():</span>
            <span class="n">season</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>  <span class="c1"># summer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Undefined Date&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">season</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>extract seasonal info from timestamp
</code></pre>

<p>Parameter</p>

<pre><code>date : pd.datetime
    timestamp of measurement to be classified

year : str
    year information of timestamp
</code></pre>

<p>Return</p>

<pre><code>season in which timestamp is
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile.check_for_christmas_new_year" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile.check_for_christmas_new_year">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">check_for_christmas_new_year</span><span class="signature">(self, year, date, dayofweek)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">check_for_christmas_new_year</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">dayofweek</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            checks if date is christmas</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>

<span class="sd">            dayofweek : str</span>



<span class="sd">        Return</span>

<span class="sd">            deactivated -&gt; returns always 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>checks if date is christmas
</code></pre>

<p>Parameter</p>

<pre><code>date : pd.datetime
    timestamp of measurement to be classified

year : str
    year information of timestamp

dayofweek : str
</code></pre>

<p>Return</p>

<pre><code>deactivated -&gt; returns always 0
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile.check_if_vacation" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile.check_if_vacation">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">check_if_vacation</span><span class="signature">(self, date)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">check_if_vacation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            checks if date is christmas</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            deactivated -&gt; returns always 0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="mi">0</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>checks if date is christmas
</code></pre>

<p>Parameter</p>

<pre><code>date : pd.datetime
    timestamp of measurement to be classified

year : str
    year information of timestamp
</code></pre>

<p>Return</p>

<pre><code>deactivated -&gt; returns always 0
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile.get_day_info" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile.get_day_info">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_day_info</span><span class="signature">(self, year, date)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_day_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            classify if day is weekday (w), saturday (sa) or sunday (su)</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            deactivated -&gt; returns always w</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">day_info</span> <span class="o">=</span> <span class="s1">&#39;w&#39;</span>
        <span class="k">return</span> <span class="n">day_info</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>classify if day is weekday (w), saturday (sa) or sunday (su)
</code></pre>

<p>Parameter</p>

<pre><code>date : pd.datetime
    timestamp of measurement to be classified

year : str
    year information of timestamp
</code></pre>

<p>Return</p>

<pre><code>deactivated -&gt; returns always w
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile.classification_day" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile.classification_day">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">classification_day</span><span class="signature">(self, date)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">classification_day</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            find season and day type</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>


<span class="sd">        Return</span>

<span class="sd">            season and day_info : str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>
        <span class="n">season</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_season_info</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span>
        <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_day_info</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">season</span><span class="p">,</span> <span class="n">day_info</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>find season and day type
</code></pre>

<p>Parameter</p>

<pre><code>date : pd.datetime
    timestamp of measurement to be classified
</code></pre>

<p>Return</p>

<pre><code>season and day_info : str
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile.sort_data_into_profile_cache" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile.sort_data_into_profile_cache">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">sort_data_into_profile_cache</span><span class="signature">(self, profile, data_on_date, date)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">sort_data_into_profile_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="n">data_on_date</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            sort day into cache to be able to make profiles</span>

<span class="sd">        Parameter</span>

<span class="sd">            profile : pd.DataFrame</span>
<span class="sd">                profile to sort data in</span>

<span class="sd">            data_on_date : pd.DataFrame</span>
<span class="sd">                data measured on date</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>


<span class="sd">        Return</span>

<span class="sd">            Return is stored in class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">profile_data_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span>
        <span class="n">data_on_date</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_on_date</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
        <span class="n">profile_data_cache</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_on_date</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_on_date</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_column</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>sort day into cache to be able to make profiles
</code></pre>

<p>Parameter</p>

<pre><code>profile : pd.DataFrame
    profile to sort data in

data_on_date : pd.DataFrame
    data measured on date

date : pd.datetime
    timestamp of measurement to be classified
</code></pre>

<p>Return</p>

<pre><code>Return is stored in class
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile.preprocess_new_data" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile.preprocess_new_data">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">preprocess_new_data</span><span class="signature">(self, incoming_data)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">preprocess_new_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incoming_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            process new data into data cache</span>

<span class="sd">        Parameter</span>

<span class="sd">            incoming_data : pd.DataFrame</span>
<span class="sd">                new measured data</span>


<span class="sd">        Return</span>

<span class="sd">            Return is stored in class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">last_timestamp</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">()</span>
        <span class="c1"># check if incoming_data contains new data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="n">last_timestamp</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">incoming_data</span><span class="o">.</span><span class="n">index</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="n">last_timestamp</span>
        <span class="c1"># extract time information</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">date</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">time</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="c1"># sort data</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">data_on_date</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span>
            <span class="n">season</span><span class="p">,</span> <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">profile_number</span> <span class="o">=</span> <span class="n">season</span> <span class="o">+</span> <span class="n">day_info</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort_data_into_profile_cache</span><span class="p">(</span><span class="n">profile_number</span><span class="p">,</span> <span class="n">data_on_date</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>process new data into data cache
</code></pre>

<p>Parameter</p>

<pre><code>incoming_data : pd.DataFrame
    new measured data
</code></pre>

<p>Return</p>

<pre><code>Return is stored in class
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile.round_up" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile.round_up">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">round_up</span><span class="signature">(self, time_now)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">round_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            rounded time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_now_round</span> <span class="o">=</span> <span class="n">time_now</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_now_round</span> <span class="o">&lt;</span> <span class="n">time_now</span><span class="p">:</span>
            <span class="n">time_now_round</span> <span class="o">=</span> <span class="n">time_now_round</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_now_round</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)
</code></pre>

<p>Parameter</p>

<pre><code>time_now : pd.datetime
    current timestamp
</code></pre>

<p>Return</p>

<pre><code>rounded time
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile.get_previous_profile" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile.get_previous_profile">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_previous_profile</span><span class="signature">(self, season, date)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_previous_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">season</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            if there is no data in the profile for current season, use values of the last season as a guess</span>

<span class="sd">        Parameter</span>

<span class="sd">            season : str</span>
<span class="sd">                classified season</span>

<span class="sd">            date : str</span>
<span class="sd">                date of measurement</span>


<span class="sd">        Return</span>

<span class="sd">            name of previous profile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">year</span>
        <span class="k">if</span> <span class="n">season</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span> <span class="ow">or</span> <span class="n">season</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;t&#39;</span>
        <span class="k">elif</span> <span class="n">season</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-05-15&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">date</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-09-14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">():</span>
                <span class="k">return</span> <span class="s1">&#39;s&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;w&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Previous Season not found!&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>if there is no data in the profile for current season, use values of the last season as a guess
</code></pre>

<p>Parameter</p>

<pre><code>season : str
    classified season

date : str
    date of measurement
</code></pre>

<p>Return</p>

<pre><code>name of previous profile
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile.forecast" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile.forecast">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">forecast</span><span class="signature">(self, time_now, forecast_horizon)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">forecast_horizon</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            Forecasting</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>

<span class="sd">            forecast_horizon : str</span>
<span class="sd">                horizon length on which predictions should be made</span>


<span class="sd">        Return</span>

<span class="sd">            forecast as pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># round up time</span>
        <span class="n">time_now_rounded_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_up</span><span class="p">(</span><span class="n">time_now</span><span class="p">)</span>
        <span class="c1"># get index over forecast horizon</span>
        <span class="n">forecast_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">time_now_rounded_up</span><span class="p">,</span>
                                       <span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_now_rounded_up</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">forecast_horizon</span><span class="p">),</span>
                                       <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="c1"># initialize dataframe to store forecast</span>
        <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">forecast_index</span><span class="p">)</span>
        <span class="c1"># extract time info</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span>
        <span class="c1"># get unique dates</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="c1"># make forecasts</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="c1"># classify days to do forecast</span>
            <span class="n">season</span><span class="p">,</span> <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">day_character</span> <span class="o">=</span> <span class="n">season</span> <span class="o">+</span> <span class="n">day_info</span>
            <span class="c1"># get profile data</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>
            <span class="c1"># calculate profile</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># if profile is not available use previous</span>
            <span class="k">if</span> <span class="n">profile</span><span class="o">.</span><span class="n">empty</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="o">.</span><span class="n">dropna</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">season</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_previous_profile</span><span class="p">(</span><span class="n">season</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
                <span class="n">day_character</span> <span class="o">=</span> <span class="n">season</span> <span class="o">+</span> <span class="n">day_info</span>
                <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>
                <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># predict</span>
            <span class="n">data_for_day</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
            <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;forecast&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">])</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>Forecasting
</code></pre>

<p>Parameter</p>

<pre><code>time_now : pd.datetime
    current timestamp

forecast_horizon : str
    horizon length on which predictions should be made
</code></pre>

<p>Return</p>

<pre><code>forecast as pd.DataFrame
</code></pre>
</div>


                            </div>
                </section>
                <section id="PersonalizedStandardizedLoadProfile_variable_length">
                                <div class="attr class">
        <a class="headerlink" href="#PersonalizedStandardizedLoadProfile_variable_length">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">PersonalizedStandardizedLoadProfile_variable_length</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PersonalizedStandardizedLoadProfile_variable_length</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Function</span>

<span class="sd">         A class to calculate the Personalized Standardized Load Profile.</span>

<span class="sd">     Principle</span>

<span class="sd">         Personalized Standardized Load Profiles or short PSLP is one simple statistical approach to</span>
<span class="sd">         forecast future loads based on historical loads. The approach is a further development of the</span>
<span class="sd">         standardized load profiles which were derived by “Verband der Elektrizitätswirtschaft e.V.”</span>
<span class="sd">         (short: VDEW). The original profiles were derived by using measurements of 1209 different buildings</span>
<span class="sd">         but with the uprising implementation of smart meters the basic rules were adopted and measured</span>
<span class="sd">         data is used to derive suitable profiles for forecasting.</span>

<span class="sd">         In the basic approach there are 11 profiles derived from the measured data. These are divided by</span>
<span class="sd">         type of day (weekdays, Saturday, Sunday/vacation) and by season (transition, winter and summer).</span>

<span class="sd">         Usually public holidays are treated as a Sunday because load patterns are more equal to that then</span>
<span class="sd">         to a usual business day. Christmas and New Year’s Day are an exception from that rule because these</span>
<span class="sd">         days are treated as a Saturday if they are not on a Sunday.</span>

<span class="sd">         During preparation of the profiles measured data are sorted into the aforementioned categories.</span>
<span class="sd">         Then the profiles are calculated using the mean value of every point of time of time in the</span>
<span class="sd">         profiles.</span>

<span class="sd">         For the use in Mini-Grids the basic idea is used to generate a profile out of the measured data but</span>
<span class="sd">         the approach is further adapted to the findings in the data of the Mini-Grid. In the data no weekly</span>
<span class="sd">         seasonality was found and every day looked more like the previous day. Therefore, this</span>
<span class="sd">         differentiation was omitted. Also, no clear annual effects of lower and higher loads were</span>
<span class="sd">         determined. Because of that the differentiation between seasons was also dropped. This leaves the</span>
<span class="sd">         idea of averaging measurements of recent days to form a load profile behind. This, by any means,</span>
<span class="sd">         does not mean that this approach is suitable for all Mini-Grids as this were the results of</span>
<span class="sd">         research conducted by now.</span>

<span class="sd">         This class has an extension compared to the normal PSLP which is that it tries to estimate best</span>
<span class="sd">         length of window size (starting at 1 Day going back to 31Days). This can increase forecast</span>
<span class="sd">         accuracy when days are more or less fluctuating without a specific pattern.</span>

<span class="sd">     Attributes</span>

<span class="sd">         target_column : str</span>
<span class="sd">             name of column to predict</span>

<span class="sd">         holiday_times : list</span>
<span class="sd">             can be filled then it is checked if a date is holiday. This is currently not implemented</span>
<span class="sd">             as vacations were not found in measurements.</span>

<span class="sd">         data_frequency : str</span>
<span class="sd">             Frequency in which prediction should be done and incoming data is</span>

<span class="sd">         cache_dict : dict</span>
<span class="sd">             storage for classified data</span>

<span class="sd">         last_processed_timestep : pd.datetime</span>
<span class="sd">             last timestep classified</span>

<span class="sd">     Methods</span>

<span class="sd">         __init_dicts()</span>
<span class="sd">             inits storage dicts</span>

<span class="sd">         __vacation_dates()</span>
<span class="sd">             get vacation dates</span>

<span class="sd">         get_season_info()</span>
<span class="sd">             info on which season data is in</span>

<span class="sd">         check_for_christmas_new_year()</span>
<span class="sd">             checks if date is christmas (currently set to always false)</span>

<span class="sd">         check_if_vacation()</span>
<span class="sd">             checks if date is vacation (currently set to always false)</span>

<span class="sd">         get_day_info()</span>
<span class="sd">             if day is weekday or Saturday or Sunday (currently set to always week)</span>

<span class="sd">         classification_day()</span>
<span class="sd">             gather all info to classify day</span>
<span class="sd">             uses get_season_info() and get_day_info()</span>

<span class="sd">         sort_data_into_profile_cache()</span>
<span class="sd">             sorts data into cache storages</span>

<span class="sd">         preprocess_new_data()</span>
<span class="sd">             preprocesses new incoming data into classes</span>

<span class="sd">         round_up()</span>
<span class="sd">             rounds up to next timestep</span>

<span class="sd">         get_previous_profile()</span>
<span class="sd">             if correct profile is not available it uses previous one</span>

<span class="sd">         forecast()</span>
<span class="sd">             forecasts future loads</span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_column</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_column</span> <span class="o">=</span> <span class="n">target_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_training</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span> <span class="o">=</span> <span class="s1">&#39;15Min&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__init_dicts</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init_dicts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># initializes data storages</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;00:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;23:59:59&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span><span class="o">.</span><span class="n">time</span>
        <span class="n">dict_with_empty_profiles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">dict_with_empty_profiles</span><span class="p">[</span><span class="s1">&#39;profile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>  <span class="c1"># weeks in winter</span>
        <span class="k">return</span> <span class="n">dict_with_empty_profiles</span>

    <span class="k">def</span> <span class="nf">get_day_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            classify if day is weekday (w), saturday (sa) or sunday (su)</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            deactivated -&gt; returns always w</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">day_info</span> <span class="o">=</span> <span class="s1">&#39;profile&#39;</span>
        <span class="k">return</span> <span class="n">day_info</span>

    <span class="k">def</span> <span class="nf">classification_day</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            find season and day type</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>


<span class="sd">        Return</span>

<span class="sd">            season and day_info : str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_day_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">day_info</span>

    <span class="k">def</span> <span class="nf">sort_data_into_profile_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_on_date</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            sort day into cache to be able to make profiles</span>

<span class="sd">        Parameter</span>

<span class="sd">            profile : pd.DataFrame</span>
<span class="sd">                profile to sort data in</span>

<span class="sd">            data_on_date : pd.DataFrame</span>
<span class="sd">                data measured on date</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>


<span class="sd">        Return</span>

<span class="sd">            Return is stored in class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sort day into cache to be able to make profiles</span>
        <span class="n">profile_data_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">)</span>
        <span class="n">data_on_date</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_on_date</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
        <span class="n">profile_data_cache</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_on_date</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_on_date</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_column</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">preprocess_new_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incoming_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            process new data into data cache</span>

<span class="sd">        Parameter</span>

<span class="sd">            incoming_data : pd.DataFrame</span>
<span class="sd">                new measured data</span>


<span class="sd">        Return</span>

<span class="sd">            Return is stored in class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># process new data into data cache</span>
        <span class="n">last_timestamp</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="n">last_timestamp</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">incoming_data</span><span class="o">.</span><span class="n">index</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="n">last_timestamp</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">date</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">time</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">data_on_date</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span>
            <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort_data_into_profile_cache</span><span class="p">(</span><span class="n">data_on_date</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">round_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            rounded time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)</span>
        <span class="n">time_now_round</span> <span class="o">=</span> <span class="n">time_now</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_now_round</span> <span class="o">&lt;</span> <span class="n">time_now</span><span class="p">:</span>
            <span class="n">time_now_round</span> <span class="o">=</span> <span class="n">time_now_round</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_now_round</span>

    <span class="k">def</span> <span class="nf">forecast_standard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">forecast_horizon</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            Forecasting</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>

<span class="sd">            forecast_horizon : str</span>
<span class="sd">                horizon length on which predictions should be made</span>


<span class="sd">        Return</span>

<span class="sd">            forecast as pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># load forecasting part</span>
        <span class="n">time_now_rounded_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_up</span><span class="p">(</span><span class="n">time_now</span><span class="p">)</span>
        <span class="n">forecast_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">time_now_rounded_up</span><span class="p">,</span>
                                       <span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_now_rounded_up</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">forecast_horizon</span><span class="p">),</span>
                                       <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">forecast_index</span><span class="p">)</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">day_character</span> <span class="o">=</span> <span class="n">day_info</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">data_for_day</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
            <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;forecast&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">forecast_fixed_recency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">forecast_horizon</span><span class="p">,</span> <span class="n">fixed_recency</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            Forecasting with a pre set recency</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>

<span class="sd">            forecast_horizon : str</span>
<span class="sd">                horizon length on which predictions should be made</span>

<span class="sd">            fixed_recency : int</span>
<span class="sd">                days of data used for calculating PSLP</span>


<span class="sd">        Return</span>

<span class="sd">            forecast as pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># load forecasting part</span>
        <span class="n">time_now_rounded_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_up</span><span class="p">(</span><span class="n">time_now</span><span class="p">)</span>
        <span class="n">forecast_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">time_now_rounded_up</span><span class="p">,</span>
                                       <span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_now_rounded_up</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">forecast_horizon</span><span class="p">),</span>
                                       <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">forecast_index</span><span class="p">)</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">day_character</span> <span class="o">=</span> <span class="n">day_info</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>

            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">fixed_recency</span><span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">data_for_day</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
            <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;forecast&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__test_recency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testing_length</span><span class="p">):</span>
        <span class="n">best_recency</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">recency</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">30</span><span class="p">):</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">)</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">recency</span><span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">profile_sum</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">tests</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">testing_length</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">tests</span> <span class="o">=</span> <span class="n">tests</span> <span class="o">-</span> <span class="n">profile_sum</span>
            <span class="n">mean_error</span> <span class="o">=</span> <span class="n">tests</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">best_recency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">best_recency</span> <span class="o">=</span> <span class="n">recency</span>
            <span class="k">if</span> <span class="n">best_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">best_error</span> <span class="o">=</span> <span class="n">mean_error</span>
            <span class="k">if</span> <span class="n">best_error</span> <span class="o">&gt;</span> <span class="n">mean_error</span><span class="p">:</span>
                <span class="n">best_recency</span> <span class="o">=</span> <span class="n">recency</span>
                <span class="n">best_error</span> <span class="o">=</span> <span class="n">mean_error</span>
        <span class="k">return</span> <span class="n">best_recency</span>

    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">forecast_horizon</span><span class="p">,</span> <span class="n">testing_length</span><span class="o">=</span><span class="mi">31</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            Forecasting with variable length recency</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>

<span class="sd">            forecast_horizon : str</span>
<span class="sd">                horizon length on which predictions should be made</span>

<span class="sd">            testing_length : int</span>
<span class="sd">                sets maximum days to test to find best recency</span>

<span class="sd">        Return</span>

<span class="sd">            forecast as pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># load forecasting part</span>
        <span class="n">time_now_rounded_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_up</span><span class="p">(</span><span class="n">time_now</span><span class="p">)</span>
        <span class="n">forecast_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">time_now_rounded_up</span><span class="p">,</span>
                                       <span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_now_rounded_up</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">forecast_horizon</span><span class="p">),</span>
                                       <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">forecast_index</span><span class="p">)</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="n">number_of_days</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">number_of_days</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">recency</span> <span class="o">=</span> <span class="n">number_of_days</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__test_recency</span><span class="p">(</span><span class="n">testing_length</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">day_character</span> <span class="o">=</span> <span class="n">day_info</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">recency</span><span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">data_for_day</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
            <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;forecast&#39;</span><span class="p">]</span>
        <span class="n">module_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;PSLP: recency set to: </span><span class="si">{</span><span class="n">recency</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">])</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>A class to calculate the Personalized Standardized Load Profile.
</code></pre>

<p>Principle</p>

<pre><code>Personalized Standardized Load Profiles or short PSLP is one simple statistical approach to
forecast future loads based on historical loads. The approach is a further development of the
standardized load profiles which were derived by “Verband der Elektrizitätswirtschaft e.V.”
(short: VDEW). The original profiles were derived by using measurements of 1209 different buildings
but with the uprising implementation of smart meters the basic rules were adopted and measured
data is used to derive suitable profiles for forecasting.

In the basic approach there are 11 profiles derived from the measured data. These are divided by
type of day (weekdays, Saturday, Sunday/vacation) and by season (transition, winter and summer).

Usually public holidays are treated as a Sunday because load patterns are more equal to that then
to a usual business day. Christmas and New Year’s Day are an exception from that rule because these
days are treated as a Saturday if they are not on a Sunday.

During preparation of the profiles measured data are sorted into the aforementioned categories.
Then the profiles are calculated using the mean value of every point of time of time in the
profiles.

For the use in Mini-Grids the basic idea is used to generate a profile out of the measured data but
the approach is further adapted to the findings in the data of the Mini-Grid. In the data no weekly
seasonality was found and every day looked more like the previous day. Therefore, this
differentiation was omitted. Also, no clear annual effects of lower and higher loads were
determined. Because of that the differentiation between seasons was also dropped. This leaves the
idea of averaging measurements of recent days to form a load profile behind. This, by any means,
does not mean that this approach is suitable for all Mini-Grids as this were the results of
research conducted by now.

This class has an extension compared to the normal PSLP which is that it tries to estimate best
length of window size (starting at 1 Day going back to 31Days). This can increase forecast
accuracy when days are more or less fluctuating without a specific pattern.
</code></pre>

<p>Attributes</p>

<pre><code>target_column : str
    name of column to predict

holiday_times : list
    can be filled then it is checked if a date is holiday. This is currently not implemented
    as vacations were not found in measurements.

data_frequency : str
    Frequency in which prediction should be done and incoming data is

cache_dict : dict
    storage for classified data

last_processed_timestep : pd.datetime
    last timestep classified
</code></pre>

<p>Methods</p>

<pre><code>__init_dicts()
    inits storage dicts

__vacation_dates()
    get vacation dates

get_season_info()
    info on which season data is in

check_for_christmas_new_year()
    checks if date is christmas (currently set to always false)

check_if_vacation()
    checks if date is vacation (currently set to always false)

get_day_info()
    if day is weekday or Saturday or Sunday (currently set to always week)

classification_day()
    gather all info to classify day
    uses get_season_info() and get_day_info()

sort_data_into_profile_cache()
    sorts data into cache storages

preprocess_new_data()
    preprocesses new incoming data into classes

round_up()
    rounds up to next timestep

get_previous_profile()
    if correct profile is not available it uses previous one

forecast()
    forecasts future loads
</code></pre>
</div>


                            <div id="PersonalizedStandardizedLoadProfile_variable_length.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile_variable_length.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">PersonalizedStandardizedLoadProfile_variable_length</span><span class="signature">(target_column)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_column</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_column</span> <span class="o">=</span> <span class="n">target_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_training</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span> <span class="o">=</span> <span class="s1">&#39;15Min&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__init_dicts</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PersonalizedStandardizedLoadProfile_variable_length.get_day_info" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile_variable_length.get_day_info">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_day_info</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_day_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            classify if day is weekday (w), saturday (sa) or sunday (su)</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>

<span class="sd">            year : str</span>
<span class="sd">                year information of timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            deactivated -&gt; returns always w</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">day_info</span> <span class="o">=</span> <span class="s1">&#39;profile&#39;</span>
        <span class="k">return</span> <span class="n">day_info</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>classify if day is weekday (w), saturday (sa) or sunday (su)
</code></pre>

<p>Parameter</p>

<pre><code>date : pd.datetime
    timestamp of measurement to be classified

year : str
    year information of timestamp
</code></pre>

<p>Return</p>

<pre><code>deactivated -&gt; returns always w
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile_variable_length.classification_day" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile_variable_length.classification_day">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">classification_day</span><span class="signature">(self, date)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">classification_day</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            find season and day type</span>

<span class="sd">        Parameter</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>


<span class="sd">        Return</span>

<span class="sd">            season and day_info : str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_day_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">day_info</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>find season and day type
</code></pre>

<p>Parameter</p>

<pre><code>date : pd.datetime
    timestamp of measurement to be classified
</code></pre>

<p>Return</p>

<pre><code>season and day_info : str
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile_variable_length.sort_data_into_profile_cache" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile_variable_length.sort_data_into_profile_cache">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">sort_data_into_profile_cache</span><span class="signature">(self, data_on_date, date)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">sort_data_into_profile_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_on_date</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            sort day into cache to be able to make profiles</span>

<span class="sd">        Parameter</span>

<span class="sd">            profile : pd.DataFrame</span>
<span class="sd">                profile to sort data in</span>

<span class="sd">            data_on_date : pd.DataFrame</span>
<span class="sd">                data measured on date</span>

<span class="sd">            date : pd.datetime</span>
<span class="sd">                timestamp of measurement to be classified</span>


<span class="sd">        Return</span>

<span class="sd">            Return is stored in class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sort day into cache to be able to make profiles</span>
        <span class="n">profile_data_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">)</span>
        <span class="n">data_on_date</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_on_date</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
        <span class="n">profile_data_cache</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_on_date</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_on_date</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_column</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>sort day into cache to be able to make profiles
</code></pre>

<p>Parameter</p>

<pre><code>profile : pd.DataFrame
    profile to sort data in

data_on_date : pd.DataFrame
    data measured on date

date : pd.datetime
    timestamp of measurement to be classified
</code></pre>

<p>Return</p>

<pre><code>Return is stored in class
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile_variable_length.preprocess_new_data" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile_variable_length.preprocess_new_data">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">preprocess_new_data</span><span class="signature">(self, incoming_data)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">preprocess_new_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incoming_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            process new data into data cache</span>

<span class="sd">        Parameter</span>

<span class="sd">            incoming_data : pd.DataFrame</span>
<span class="sd">                new measured data</span>


<span class="sd">        Return</span>

<span class="sd">            Return is stored in class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># process new data into data cache</span>
        <span class="n">last_timestamp</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="n">last_timestamp</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">incoming_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">incoming_data</span><span class="o">.</span><span class="n">index</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_processed_timestep</span> <span class="o">=</span> <span class="n">last_timestamp</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">date</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">time</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">data_on_date</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span>
            <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort_data_into_profile_cache</span><span class="p">(</span><span class="n">data_on_date</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>process new data into data cache
</code></pre>

<p>Parameter</p>

<pre><code>incoming_data : pd.DataFrame
    new measured data
</code></pre>

<p>Return</p>

<pre><code>Return is stored in class
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile_variable_length.round_up" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile_variable_length.round_up">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">round_up</span><span class="signature">(self, time_now)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">round_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>


<span class="sd">        Return</span>

<span class="sd">            rounded time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)</span>
        <span class="n">time_now_round</span> <span class="o">=</span> <span class="n">time_now</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_now_round</span> <span class="o">&lt;</span> <span class="n">time_now</span><span class="p">:</span>
            <span class="n">time_now_round</span> <span class="o">=</span> <span class="n">time_now_round</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_now_round</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)
</code></pre>

<p>Parameter</p>

<pre><code>time_now : pd.datetime
    current timestamp
</code></pre>

<p>Return</p>

<pre><code>rounded time
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile_variable_length.forecast_standard" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile_variable_length.forecast_standard">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">forecast_standard</span><span class="signature">(self, time_now, forecast_horizon)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">forecast_standard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">forecast_horizon</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            Forecasting</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>

<span class="sd">            forecast_horizon : str</span>
<span class="sd">                horizon length on which predictions should be made</span>


<span class="sd">        Return</span>

<span class="sd">            forecast as pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># load forecasting part</span>
        <span class="n">time_now_rounded_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_up</span><span class="p">(</span><span class="n">time_now</span><span class="p">)</span>
        <span class="n">forecast_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">time_now_rounded_up</span><span class="p">,</span>
                                       <span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_now_rounded_up</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">forecast_horizon</span><span class="p">),</span>
                                       <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">forecast_index</span><span class="p">)</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">day_character</span> <span class="o">=</span> <span class="n">day_info</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">data_for_day</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
            <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;forecast&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">])</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>Forecasting
</code></pre>

<p>Parameter</p>

<pre><code>time_now : pd.datetime
    current timestamp

forecast_horizon : str
    horizon length on which predictions should be made
</code></pre>

<p>Return</p>

<pre><code>forecast as pd.DataFrame
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile_variable_length.forecast_fixed_recency" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile_variable_length.forecast_fixed_recency">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">forecast_fixed_recency</span><span class="signature">(self, time_now, forecast_horizon, fixed_recency=7)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">forecast_fixed_recency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">forecast_horizon</span><span class="p">,</span> <span class="n">fixed_recency</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            Forecasting with a pre set recency</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>

<span class="sd">            forecast_horizon : str</span>
<span class="sd">                horizon length on which predictions should be made</span>

<span class="sd">            fixed_recency : int</span>
<span class="sd">                days of data used for calculating PSLP</span>


<span class="sd">        Return</span>

<span class="sd">            forecast as pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># load forecasting part</span>
        <span class="n">time_now_rounded_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_up</span><span class="p">(</span><span class="n">time_now</span><span class="p">)</span>
        <span class="n">forecast_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">time_now_rounded_up</span><span class="p">,</span>
                                       <span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_now_rounded_up</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">forecast_horizon</span><span class="p">),</span>
                                       <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">forecast_index</span><span class="p">)</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">day_character</span> <span class="o">=</span> <span class="n">day_info</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>

            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">fixed_recency</span><span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">data_for_day</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
            <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;forecast&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">])</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>Forecasting with a pre set recency
</code></pre>

<p>Parameter</p>

<pre><code>time_now : pd.datetime
    current timestamp

forecast_horizon : str
    horizon length on which predictions should be made

fixed_recency : int
    days of data used for calculating PSLP
</code></pre>

<p>Return</p>

<pre><code>forecast as pd.DataFrame
</code></pre>
</div>


                            </div>
                            <div id="PersonalizedStandardizedLoadProfile_variable_length.forecast" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PersonalizedStandardizedLoadProfile_variable_length.forecast">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">forecast</span><span class="signature">(self, time_now, forecast_horizon, testing_length=31)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">forecast_horizon</span><span class="p">,</span> <span class="n">testing_length</span><span class="o">=</span><span class="mi">31</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function</span>

<span class="sd">            Forecasting with variable length recency</span>

<span class="sd">        Parameter</span>

<span class="sd">            time_now : pd.datetime</span>
<span class="sd">                current timestamp</span>

<span class="sd">            forecast_horizon : str</span>
<span class="sd">                horizon length on which predictions should be made</span>

<span class="sd">            testing_length : int</span>
<span class="sd">                sets maximum days to test to find best recency</span>

<span class="sd">        Return</span>

<span class="sd">            forecast as pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># load forecasting part</span>
        <span class="n">time_now_rounded_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_up</span><span class="p">(</span><span class="n">time_now</span><span class="p">)</span>
        <span class="n">forecast_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">time_now_rounded_up</span><span class="p">,</span>
                                       <span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_now_rounded_up</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">forecast_horizon</span><span class="p">),</span>
                                       <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_frequency</span><span class="p">)</span>
        <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">forecast_index</span><span class="p">)</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span>
        <span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span>
        <span class="n">unique_dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">forecast_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="n">number_of_days</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">number_of_days</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">recency</span> <span class="o">=</span> <span class="n">number_of_days</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__test_recency</span><span class="p">(</span><span class="n">testing_length</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">unique_dates</span><span class="p">:</span>
            <span class="n">day_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_day</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">day_character</span> <span class="o">=</span> <span class="n">day_info</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">day_character</span><span class="p">)</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">cached_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">recency</span><span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">data_for_day</span> <span class="o">=</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">forecast_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
            <span class="n">forecast_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_for_day</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;forecast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_for_day</span><span class="p">[</span><span class="s1">&#39;forecast&#39;</span><span class="p">]</span>
        <span class="n">module_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;PSLP: recency set to: </span><span class="si">{</span><span class="n">recency</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">forecast_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">])</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function</p>

<pre><code>Forecasting with variable length recency
</code></pre>

<p>Parameter</p>

<pre><code>time_now : pd.datetime
    current timestamp

forecast_horizon : str
    horizon length on which predictions should be made

testing_length : int
    sets maximum days to test to find best recency
</code></pre>

<p>Return</p>

<pre><code>forecast as pd.DataFrame
</code></pre>
</div>


                            </div>
                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">(${doc.parameters.join(", ")})</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>