window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "main", "modulename": "main", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "main.main", "modulename": "main", "qualname": "main", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Main forecasting function to be used in production phase. This function calls forecasting procedure\nonce and writes predictions into output excel file to be used in linear optimizer.\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>General workflow is described in Documentation Doc provided to INENSUS. Some further notes here:\nAt first current timestamp is retrieved from system time and coverted/localized to timezone of\nsite. It is important that timezone is set correctly in Config.txt provided with the tool in\n[general] section.\n\nFor socket server path is read from Config.txt (please change if needed in Config in\nsection [general].\n\nForecasting module is then loaded in which is the main script combining different functions to:\n1. update data\n2. eval recent forecasts\n3. prepare datasets for forecasting and training\n4. train Neural Network\n5. Predict with Neural Network\n6. Predict with statistical and persistency models\n7. Save forecast to Excel to provide it to linear optimizer\n</code></pre>\n\n<p>Additional Notes</p>\n\n<pre><code>Testing Purpose:\nFor testing please use main_test_run by enabling testing mode via config file.\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>Nothing to Return\n</code></pre>\n", "parameters": [], "funcdef": "def"}, {"fullname": "main.reset_datasets", "modulename": "main", "qualname": "reset_datasets", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Shortening dataset to specified date. This is important when testing functions. Datasets are\nshortened to specified date to use in testing stage to not contain data which would not be\navailable. All methods are then used as intended in a standalone environment\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>date (pd.datetime): date to be used in format of: year-month-day hour:minutes\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>Nothing to return datasets are saved in their respective folder directly\n</code></pre>\n\n<p>Notes\n    Function should be used only in testing and troubleshooting before using main_test_run function.</p>\n", "parameters": ["date", "path_pre"], "funcdef": "def"}, {"fullname": "main.remove_files_folders", "modulename": "main", "qualname": "remove_files_folders", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Removes all files from previous test runs and therefore does a clean start.\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>top: string or path to folder where data should be removed\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>Nothing to return\n</code></pre>\n", "parameters": ["top"], "funcdef": "def"}, {"fullname": "main.reset_models_predictions_evaluation", "modulename": "main", "qualname": "reset_models_predictions_evaluation", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Removes folders containing: trained models, predictions and evaluation\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>path (str): absolute path to folder where data should be removed\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>Nothing to return\n</code></pre>\n", "parameters": ["path"], "funcdef": "def"}, {"fullname": "main.main_test_run", "modulename": "main", "qualname": "main_test_run", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Testing forecasting function to be used in production phase. This function calls\nforecasting procedure once and writes predictions into output excel file to be used\nin linear optimizer.\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>General workflow is described in Documentation Doc provided to INENSUS.\nSome further notes here: At first current timestamp is retrieved from system time and\ncoverted/localized to timezone of site. It is important that timezone is set correctly\nin Config.txt provided with the tool in [general] section.\n\nFor socket server path is read from Config.txt (please change if needed in Config\nin section [general]\n\nForecasting module is then loaded in which is the main script combining different functions to:\n1. update data\n2. eval recent forecasts\n3. prepare datasets for forecasting and training\n4. train Neural Network\n5. Predict with Neural Network\n6. Predict with statistical and persistency models\n7. Save forecast to Excel to provide it to linear optimizer\n</code></pre>\n\n<p>Additional Notes</p>\n\n<pre><code>Testing Purpose:\nFor productive phase use main by disabling testing mode via config file.\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>Nothing to Return\n</code></pre>\n", "parameters": ["date", "shift_by"], "funcdef": "def"}, {"fullname": "forecasting_module", "modulename": "forecasting_module", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "forecasting_module.mp_function", "modulename": "forecasting_module", "qualname": "mp_function", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>In this function all parts for forecasting with the AI are combined.\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>It is necessary to move AI parts into a different process in order to have fast computing of neural network training.\nThis is because Tensorflow does not allow training of multiple neural networks in one session and to have a\nclean cut between sessions these are calculated in different processes. This also leads to lower memory usage\nbecause memory is freed after ever session leaving no used dataset and neural networks in RAM after process has finished.\nTo do so also dataset creation has to be done in the same process because otherwise tensorflow does not allow\ntraining (because these were then created in another session).\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>queue : mp.Queue\n    queue to send data back to main process\n\npart : str\n    part which gets AI training/prediction\n\nforecasting_mode : bool\n    True : no training is done\n    False: AI gets trained\n\ncurrent_path : str\n    current folder\n\ntime_now : pd.datetime\n    time of current prediction\n\nargs : dict/list...\n    optional arguments\n</code></pre>\n", "parameters": ["queue", "part", "forecasting_mode", "current_path", "time_now", "args"], "funcdef": "def"}, {"fullname": "forecasting_module.ForecastingModule", "modulename": "forecasting_module", "qualname": "ForecastingModule", "type": "class", "doc": "<p>Function</p>\n\n<pre><code>ForecastingModule(FM) combines all important functions to forecast Power Generation and Load.\nThis is the main function which should be called instead of utilizing the different functions\nthemselves. This makes using all needed functions easy and straight forward. Respective methods\nof the utilized classes are further described in their specific parts.\n</code></pre>\n\n<p>Order &amp; Methods:</p>\n\n<pre><code>As described in documentation file order of methods used is as follows:\n1. update_data: gets new data from server and standardizes data for following steps\n2. eval_recent_forecasts: evaluates all recent predictions\n3. prepare_datasets: prepares datasets concerning missing values, double values,\n    features needed, shape needed\n4. train: trains algorithm if specified by eval_recemt_forecasts method\n5. ai_forecast: predicts with ML algorithms\n6. add_statistical_forecasts: Adding statistical forecasts\n7. forecasts_to_excel: writes the forecasts to excel file of optimizer\n</code></pre>\n\n<p>Attributes</p>\n\n<pre><code>forecasting_mode : bool\n     variable to enable or disable training. On devices like nvidia Jetson True is\n     recommended else False\n\nweather : class\n     which updates and prepares weather data from server\n\npv : class\n     for preparing pv data\n\nload : class\n     for preparing load data\n\nai : class\n     which has all ai models, training and prediction methods\n\neval : class\n    which evaluates recent forecasts and recommends training and model to use\n</code></pre>\n"}, {"fullname": "forecasting_module.ForecastingModule.__init__", "modulename": "forecasting_module", "qualname": "ForecastingModule.__init__", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Initializes all needed modules for: WeatherData, PV-Forecasting, Load-Forecasting, AI,\nEvaluation\n</code></pre>\n\n<p>Attributes</p>\n\n<pre><code>forecasting_mode : bool\n     variable to enable or disable training. On devices like nvidia Jetson True is recommended\n     else False\n\nweather : class\n     which updates and prepares weather data from server\n\npv : class\n     for preparing pv data\n\nload : class\n     for preparing load data\n\nai : class\n     which has all ai models, training and prediction methods\n\neval : class\n    evaluates recent forecasts and recommends training and model to use\n</code></pre>\n", "parameters": ["self", "current_path"], "funcdef": "def"}, {"fullname": "forecasting_module.ForecastingModule.update_data", "modulename": "forecasting_module", "qualname": "ForecastingModule.update_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>First step of forecasting is to update all data. This invokes for PV, Load and WeatherModule\nthe responsible methods to download new data, preprocess them and add these new data to already\navailable datasets.\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>time_now: pd.datetime\n    current datetime\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>No returns needed as data is stored in class itself\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "forecasting_module.ForecastingModule.prepare_train_predict", "modulename": "forecasting_module", "qualname": "ForecastingModule.prepare_train_predict", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>starts process to prepare dataset, train AI (optional) and predict\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : pd.datetime\n    current time for forecasting\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "forecasting_module.ForecastingModule.prepare_datasets", "modulename": "forecasting_module", "qualname": "ForecastingModule.prepare_datasets", "type": "function", "doc": "<p>DEPRECATED\nFunction</p>\n\n<pre><code>combines all functions from the subclasses to prepare datasets for training and forecasting.\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>There are in total four commands utilizing preparations for long and short term dataset\npreparation for PV and Load respectively.\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>time_now:  pd.datetime\n    current datetime\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>No returns needed as data is stored in class itself\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "forecasting_module.ForecastingModule.train", "modulename": "forecasting_module", "qualname": "ForecastingModule.train", "type": "function", "doc": "<p>DEPRECATED\nFunction</p>\n\n<pre><code>trains all needed models if needed.\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>The decision when to train a network is done in eval-class (please see evaluation class\nfor further information on that). Within eval-class a dictionary contains recommendations\nfor training or deleting a model in order to do a clean start (self.eval.recommendation).\nData for training are directly extracted for PV and Load class.\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>time_now:  pd.datetime\n    current datetime\n</code></pre>\n\n<p>See also</p>\n\n<pre><code>- LoadForecasting\n- PVForecasting\n- EvaluationModule\n- AI\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>No returns needed as data is stored in class itself\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "forecasting_module.ForecastingModule.ai_forecast", "modulename": "forecasting_module", "qualname": "ForecastingModule.ai_forecast", "type": "function", "doc": "<p>DEPRECATED\nFunction</p>\n\n<pre><code>Predicts with neural networks\n</code></pre>\n\n<p>See also</p>\n\n<pre><code>- LoadForecasting\n- PVForecasting\n- Scaler\n- AI\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>No returns needed as data is stored in class itself\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "forecasting_module.ForecastingModule.add_statistical_forecasts", "modulename": "forecasting_module", "qualname": "ForecastingModule.add_statistical_forecasts", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Predicts with statistical approaches\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>time_now: pd.datetime\n    current datetime\n</code></pre>\n\n<p>See also</p>\n\n<pre><code>- LoadForecasting\n- PVForecasting\n- AI\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>No returns needed as data is stored in class itself\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "forecasting_module.ForecastingModule.eval_recent_forecasts", "modulename": "forecasting_module", "qualname": "ForecastingModule.eval_recent_forecasts", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Evaluate the forecasts of previous predictions and recommends training or resetting models\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>Latest data is used to do evaluation of recent forecasts\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>time_now: pd.datetime\n    current datetime\n</code></pre>\n\n<p>See also</p>\n\n<pre><code>- LoadForecasting\n- PVForecasting\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>No returns needed as data is stored in class itself\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "forecasting_module.ForecastingModule.forecasts_to_excel", "modulename": "forecasting_module", "qualname": "ForecastingModule.forecasts_to_excel", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Output predictions to excel and csv file for optimizer\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>Excel-file provide data directly for linear optimizer whereas csv is used internally for evaluation\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>time_now: pd.datetime\n    current datetime\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>No returns needed as data is stored in class itself\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "AI", "modulename": "AI", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "AI.train_var", "modulename": "AI", "qualname": "train_var", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>additional variables needed for training\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>train_vars : dict\n    containing batch size, epochs and learning rate\n</code></pre>\n", "parameters": [], "funcdef": "def"}, {"fullname": "AI.train_val_split", "modulename": "AI", "qualname": "train_val_split", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Splitting tensors into train and val dataset\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>train_dataset_x : tf.tensor\n    data of features for training\n\ntrain_dataset_y : tf.tensor\n    data of target value for training\n\nsplit : float [0,1]\n    determines share of data in each category\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>train_dataset_part : tf.tensor\n    train dataset\n\nval_dataset_part : tf.tensor\n    validation dataset\n</code></pre>\n", "parameters": ["train_dataset_x", "train_dataset_y", "split"], "funcdef": "def"}, {"fullname": "AI.AI", "modulename": "AI", "qualname": "AI", "type": "class", "doc": "<p>Function</p>\n\n<pre><code>All methods needed to train the AI and predict with the AI\n</code></pre>\n\n<p>Methods</p>\n\n<pre><code>reset_predictions\n__load_saved_model\n__load_model_train\nprepare_model\ntrain\nforecast\n</code></pre>\n\n<p>Attributes</p>\n\n<pre><code>models : dict\n    dict with all needed model\n    s\nuntrained_models : dict of bool\n    dictionary to keep track of which model is already trained\n\nforecast_mode : bool\n    selection if forecast mode is on\n\npredictions : dict of dataframes\n    recent predictions\n</code></pre>\n"}, {"fullname": "AI.AI.__init__", "modulename": "AI", "qualname": "AI.__init__", "type": "function", "doc": "<p>Attributes</p>\n\n<pre><code>models : dict\n    dict with all needed\n\nuntrained_models : dict of bool\n    dictionary to keep track of which model is already trained\n\nforecast_mode : bool\n    selection if forecast mode is on\n\npredictions : dict of dataframes\n    recent predictions\n</code></pre>\n", "parameters": ["self", "forecast_mode", "path", "part"], "funcdef": "def"}, {"fullname": "AI.AI.create_dataset", "modulename": "AI", "qualname": "AI.create_dataset", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>creates train test forecasting data for every part and trains/loads scaler\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>data : pd.DataFrame\n    measurements from Mini-Grid for forecasting part (Load or PV)\n\ntarget_columns : str\n    target column to use as target for training / forecasting\n\ntime_now : str / pd.datetime\n    datetime at which prediction is done\n\nforecasting_mode : bool\n    Mode in which programm is currently running (True: No Training Step)\n\npart : str\n    part which is under investigation (lf_short, lf_long, pv_short or pv_long)\n\nopt_args : None / Any\n    optional arguments to be used\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>created_data : dict\n    created data to use for training and forecasting and also some optional data\n</code></pre>\n", "parameters": ["self", "data", "target_column", "time_now", "forecasting_mode", "part", "opt_args"], "funcdef": "def"}, {"fullname": "AI.AI.reset_predictions", "modulename": "AI", "qualname": "AI.reset_predictions", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>sets predictions to None\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "AI.AI.prepare_model", "modulename": "AI", "qualname": "AI.prepare_model", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>laods model or compiles it\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>stored in class\n</code></pre>\n", "parameters": ["self", "part"], "funcdef": "def"}, {"fullname": "AI.AI.train", "modulename": "AI", "qualname": "AI.train", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Train the AI\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>recommendation : dict\n    recommendation if retrain or new model\n\npart : str\n    Which model to load: lf_long, lf_short, pv_long or pv_short\n\ndata : dict with tensors\n    train val data\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "recommendation", "part", "data", "time_now"], "funcdef": "def"}, {"fullname": "AI.AI.forecast", "modulename": "AI", "qualname": "AI.forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Forecast with AI Model\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>part : str\n    Which model to load: lf_long, lf_short, pv_long or pv_short\n\ndata : dict with tensors\n    train, val, forecast data\n\nscaler : class scaler\n    scaler trained with part data\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>prediction : pd.DataFrame\n    AI prediction\n</code></pre>\n", "parameters": ["self", "part", "data"], "funcdef": "def"}, {"fullname": "dataset_preparation_ai", "modulename": "dataset_preparation_ai", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dataset_preparation_ai.supervised_data_pv_long_term", "modulename": "dataset_preparation_ai", "qualname": "supervised_data_pv_long_term", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Algorithm for long term PV forecast needs special data format shown under principle\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>preprocessed_long_weather : pd.DataFrame\n    data with NASA weather data\n\ndataset_with_horizon : pd.DataFrame\n    prolonged data, data with forecast horizon\n\nforecast_mode : bool\n    if true scaler is not refitted\n\nscaler : scaler\n    scaler used to scale data\n\ntime_now : datetime\n    current timestamp\n\nsplit : float\n    split data into train and test data for training\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dict with train, val and forecast data\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>Dataset has to be in a 3D Shape with [Samples, Timestep, Features]\nSmall Example:\n\nRaw Dataset Sample:\nTimestamp| Target | Feature 1 | Feature 2 |\n-------------------------------------------\nT1       | M1     | F1(T1)  | F2(T1)      |\nT2       | M2     | F1(T2)  | F2(T2)      |\nT3       | M3     | F1(T3)  | F2(T3)      |\n...      | ...    | ...     | ...         |\n\n3 Datasets are needed:\nTrain_x, Train_y, Forecast_x\n\nTrain_x contains all features or observations describing target measurement at specific timestamp\nTrain_y contains all data which are the target measurements\nforecast_x is the same as train_x with only values used for future observations\n\nFor long term PV:\nTrain_x consists of weather variables of NASA Dataset (shape: [varying, 24*90 = 2160, 90 (which is feature 1-90)]\nTrain_y are the PV measurements [varying, 2160, 1 (which is target)]\nForecast_x weather variables NASA Dataset over future hours [1, 2160, 90 (which is feature 1-90)]\n\nthere is also a Split of train_x and train_y into train and val data. e.g. 0.9 of the data are in train and 0.1 in val\n</code></pre>\n", "parameters": ["preprocessed_long_weather", "dataset_with_horizon", "forecast_mode", "scaler", "time_now", "split"], "funcdef": "def"}, {"fullname": "dataset_preparation_ai.split_short_term_dataset_pv", "modulename": "dataset_preparation_ai", "qualname": "split_short_term_dataset_pv", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>splitting data into train and forecast\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>dataset : pd.DataFrame\n    dataset to split\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>train_x : pd.DataFrame\n    trainingdataset with features\n\ntrain_y : pd.DataFrame or pd.Series\n    training dataset containing measurements\n\nforecast_x : pd.DataFrame\n    forecast dataset with features\n</code></pre>\n", "parameters": ["dataset"], "funcdef": "def"}, {"fullname": "dataset_preparation_ai.function_dataset_short_term_pv_forecast", "modulename": "dataset_preparation_ai", "qualname": "function_dataset_short_term_pv_forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>prepare dataset for short term forecasting\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current time\n\nhistorical_weather_data : pd.DataFrame\n    historical weather data collected\n\nforecast_data : pd.DataFrame\n    weather forecasts from OWM\n\nforecast_mode : bool\n    if scaler is refittet or not\n\nsplit : float [0, 1]\n    split of validation and training\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dataset_short_term_forecast : dict with tensors\n    train, val, forecast datasets\n</code></pre>\n", "parameters": ["data", "target_column", "time_now", "scaler", "forecast_mode", "split"], "funcdef": "def"}, {"fullname": "dataset_preparation_ai.function_dataset_long_term_pv_forecast", "modulename": "dataset_preparation_ai", "qualname": "function_dataset_long_term_pv_forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>prepare dataset for long term forecasting\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current time\n\nlong_term_weather_data : pd.DataFrame\n    NASA long term weather data\n\nforecast_mode : bool\n    if forecast mode is activated\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dataset_long_term_forecast : dict of tensors\n    train, val, forecast datasets\n</code></pre>\n", "parameters": ["data", "target_column", "time_now", "scaler", "forecast_mode", "split", "opt_args"], "funcdef": "def"}, {"fullname": "dataset_preparation_ai.supervised_data_load_short_term", "modulename": "dataset_preparation_ai", "qualname": "supervised_data_load_short_term", "type": "function", "doc": "<p>train data to supervised</p>\n", "parameters": ["train", "split"], "funcdef": "def"}, {"fullname": "dataset_preparation_ai.split_short_term_dataset", "modulename": "dataset_preparation_ai", "qualname": "split_short_term_dataset", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Split data into train and forecast dataset\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>dataset : pd.DataFrame\n    Load data to split in train and forecast datasets\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>train_x : pd.DataFrame\n    training dataset with features\ntrain_y : pd.DataFrame or pd.Series\n    training dataset containing measurements\nforecast_x : pd.DataFrame\n    forecast dataset with features\n</code></pre>\n", "parameters": ["dataset"], "funcdef": "def"}, {"fullname": "dataset_preparation_ai.split_long_term_dataset", "modulename": "dataset_preparation_ai", "qualname": "split_long_term_dataset", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>splitting data into train and forecast\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>dataset : pd.DataFrame\n    dataset to split\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>x : pd.DataFrame\n    all features\ny : pd.DataFrame\n    measurements\n</code></pre>\n", "parameters": ["dataset"], "funcdef": "def"}, {"fullname": "dataset_preparation_ai.to_current_date", "modulename": "dataset_preparation_ai", "qualname": "to_current_date", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>augments data to current date if measurements are not coming in\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current timestamp\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>Data without missing values up to current timestamp\n</code></pre>\n", "parameters": ["time_now", "data", "optional_args"], "funcdef": "def"}, {"fullname": "dataset_preparation_ai.function_dataset_short_term_load_forecast", "modulename": "dataset_preparation_ai", "qualname": "function_dataset_short_term_load_forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>calculate features for short term forecast\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current timestamp\nforecast_mode : bool\n    activate train\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dataset_short_term_forecast : dict\n    all data needed for train and forecast\n</code></pre>\n", "parameters": ["data", "target_column", "time_now", "scaler", "forecast_mode", "split", "opt_args"], "funcdef": "def"}, {"fullname": "dataset_preparation_ai.dataset_to_supervised", "modulename": "dataset_preparation_ai", "qualname": "dataset_to_supervised", "type": "function", "doc": "<p>supervised for long term</p>\n", "parameters": ["data", "residuum", "pslp", "positional_encoding_in", "positional_encoding_out", "hist_sequence_length", "forecast_sequence_length", "split"], "funcdef": "def"}, {"fullname": "dataset_preparation_ai.function_dataset_long_term_load_forecast", "modulename": "dataset_preparation_ai", "qualname": "function_dataset_long_term_load_forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>calculate features for long term forecast\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current timestamp\nforecast_mode : bool\n    activate train\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dataset_short_term_forecast : dict\n    all data needed for train and forecast\n</code></pre>\n", "parameters": ["data", "target_column", "time_now", "scaler", "forecast_mode", "split", "opt_args"], "funcdef": "def"}, {"fullname": "models", "modulename": "models", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "models.TransformerEncoderLayer", "modulename": "models", "qualname": "TransformerEncoderLayer", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Combines all layers needed to form one layer of the TransformerEncoder. One of these layers\nconsists of:\n\nInput -&gt; MultiHeadAttention -&gt; Dropout-&gt; Normalization (optional) -&gt; Fully-Connected Dense\n -&gt; Dropout -&gt; Normalization (optional)\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>input : tensorflow layer output\n    Input to layer\n\ninput_shape : tuple\n    Shape of Input (Usually None, Features)\n\nnhead : int\n    number of heads of MultiHeadAttention layer\n\nkey_dim : int\n    Dimension of data\n\ndim_feedforward : int\n    Number of Neurons of Dense Layer\n\ndropout : float\n    fraction of dropout\n\nactivation_feedforward : str\n    Keras activation function for dense layer\n\nnormalize : bool\n    Use normalization inside layer\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>input_encoder : tensorflow layer input\n    Input to layer\n\nconcat_fully_mha : tensorflow layer output\n    Output of layer\n</code></pre>\n", "parameters": ["input", "input_shape", "nhead", "key_dim", "dim_feedforward", "dropout", "activation_feedforward", "normalize"], "funcdef": "def"}, {"fullname": "models.TransformerDecoderLayer", "modulename": "models", "qualname": "TransformerDecoderLayer", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Combines all layers needed to form one layer of the TransformerDecoder. One of these layers\nconsists of:\n\nOutput of encoder -&gt; MultiHeadAttention -&gt; Dropout-&gt; Concatenation with decoder input -&gt;\nNormalization (optional) -&gt;  MultiHeadAttention -&gt; Dropout-&gt; Normalization (optional) -&gt;\nFully-Connected Dense-&gt; Dropout -&gt; Normalization (optional)\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>input : tensorflow layer output\n    Input to layer\n\ninput_shape : tuple\n    Shape of Input (Usually None, Features)\n\nnhead : int\n    number of heads of MultiHeadAttention layer\n\nkey_dim : int\n    Dimension of data\n\ndim_feedforward : int\n    Number of Neurons of Dense Layer\n\ndropout : float\n    fraction of dropout\n\nactivation_feedforward : str\n    Keras activation function for dense layer\n\nnormalize : bool\n    Use normalization inside layer\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>input_encoder : tensorflow layer input\n    Input to layer\n\nconcat_fully_mha : tensorflow layer output\n    Output of layer\n</code></pre>\n", "parameters": ["encoder_output", "input_decoder", "decoder_input_shape", "nhead", "key_dim", "dim_feedforward", "dropout", "activation_feedforward", "normalize"], "funcdef": "def"}, {"fullname": "models.model_short_term_pv_forecasting", "modulename": "models", "qualname": "model_short_term_pv_forecasting", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Model for short term pv forecasting\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>number_of_features : int\n    number of features\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>model : tf.keras.model\n    AI model for short term pv forecasting\n</code></pre>\n", "parameters": ["number_of_features"], "funcdef": "def"}, {"fullname": "models.model_long_term_pv_forecasting", "modulename": "models", "qualname": "model_long_term_pv_forecasting", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Model for long term pv forecasting\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>model : keras.model\n    AI model for long term pv forecasting\n</code></pre>\n", "parameters": [], "funcdef": "def"}, {"fullname": "models.model_short_term_load_forecasting", "modulename": "models", "qualname": "model_short_term_load_forecasting", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Model for sort term load forecasting\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>historical_timesteps : int\n    length of historical\n\nforecast_timestep : int\n    length of prediction sequence\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>model : keras.model\n    AI model for short term load forecasting\n</code></pre>\n", "parameters": ["historical_timesteps", "forecast_timesteps"], "funcdef": "def"}, {"fullname": "models.model_long_term_load_forecasting", "modulename": "models", "qualname": "model_long_term_load_forecasting", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Model for long term load forecasting\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>historical_timesteps : int\n    length of historical input\n\nforecast_timestep : int\n    length of prediction sequence\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>model : keras.model\n    AI model for long term load forecasting\n</code></pre>\n", "parameters": [], "funcdef": "def"}, {"fullname": "routines", "modulename": "routines", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "routines.predict", "modulename": "routines", "qualname": "predict", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Predicts future values\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>model : keras.model\n    trained ml model\n\nforecast_x : tensor\n    features needed for forecast\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>prediction : np.array\n    prediction of future values\n</code></pre>\n", "parameters": ["model", "forecast_x"], "funcdef": "def"}, {"fullname": "routines.train_step", "modulename": "routines", "qualname": "train_step", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Training on one batch\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>model : keras.model\n    ai model for forecasting\n\nx_batch_train : tensor.batch\n    batched tensor containing training feature data\n\ny_batch_train : tensor.batch\n    batched tensor containing training measurement data\n\noptimizer : keras.optimizer\n    Optimizer used for training\n\nloss_fn : keras.loss_function\n    loss function to calculate accuracy\ntrain_acc_metric : keras.loss_function\n\n    accuracy metric\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>loss_value : keras.loss\n    loss value\n</code></pre>\n", "parameters": ["model", "x_batch_train", "y_batch_train", "optimizer", "loss_fn", "train_acc_metric"], "funcdef": "def"}, {"fullname": "routines.test_step", "modulename": "routines", "qualname": "test_step", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Testing on one batch\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>model : keras.model\n    ai model for forecasting\n\nx_batch_val : tensor.batch\n    batched tensor containing training feature data\n\ny_batch_val : tensor.batch\n    batched tensor containing training measurement data\n\nval_acc_metric : keras.loss_function\n    accuracy metric\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["model", "x_batch_val", "y_batch_val", "val_acc_metric"], "funcdef": "def"}, {"fullname": "routines.train_test_loss_graph", "modulename": "routines", "qualname": "train_test_loss_graph", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>draws train test loss picture\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>train_loss : list\n    list of train_losses\n\ntest_loss\n    list of test_losses\n\npath_pre : str\n    path to folder to save to\n\npart : str\n    which algorithm is trained (e.g. PV-Long)\n\ntime_now : pd.datetime\n    current time\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None / Written to file\n</code></pre>\n", "parameters": ["train_loss", "test_loss", "path_pre", "part", "time_now"], "funcdef": "def"}, {"fullname": "routines.train_multi_input", "modulename": "routines", "qualname": "train_multi_input", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Training routine for AI models\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>model : keras.model\n    AI - Model to train\n\ntrain_dataset : dict\n    Data to train Algorithm with\n\nval_dataset : dict\n    Data to evaluate Algorithm with\n\ntrain_acc_metric : tf.keras.Metric\n    Metric applied to quantify training\n\nval_acc_metric : tf.keras.Metric\n    Metric applied to quantify validation\n\noptimizer : tf.keras.Optimizer\n    Optimizer used to train algorithm\n\nloss_fn : tf.keras.Loss\n    loss function used by optimizer for training\n\npatience : int\n    Epochs to wait before stopping training\n\nepochs : int\n    Epochs to train Network at maximum\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>trained model\n</code></pre>\n", "parameters": ["model", "train_dataset", "val_dataset", "train_acc_metric", "optimizer", "loss_fn", "val_acc_metric", "patience", "epochs"], "funcdef": "def"}, {"fullname": "configuration_class", "modulename": "configuration_class", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "configuration_class.Configuration", "modulename": "configuration_class", "qualname": "Configuration", "type": "class", "doc": "<p></p>\n"}, {"fullname": "configuration_class.Configuration.__init__", "modulename": "configuration_class", "qualname": "Configuration.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "configuration_class.Configuration.CONFIG_FILE_PATH", "modulename": "configuration_class", "qualname": "Configuration.CONFIG_FILE_PATH", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "configuration_class.Configuration.checkConfigFile", "modulename": "configuration_class", "qualname": "Configuration.checkConfigFile", "type": "function", "doc": "<p>Check whether the model file is accessible</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "configuration_class.Configuration.getConfigFilePath", "modulename": "configuration_class", "qualname": "Configuration.getConfigFilePath", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "configuration_class.Configuration.setConfigFilePath", "modulename": "configuration_class", "qualname": "Configuration.setConfigFilePath", "type": "function", "doc": "<p></p>\n", "parameters": ["filePath"], "funcdef": "def"}, {"fullname": "configuration_class.Configuration.getConfigValue", "modulename": "configuration_class", "qualname": "Configuration.getConfigValue", "type": "function", "doc": "<p></p>\n", "parameters": ["sectionName", "key"], "funcdef": "def"}, {"fullname": "configuration_class.Configuration.setConfigValue", "modulename": "configuration_class", "qualname": "Configuration.setConfigValue", "type": "function", "doc": "<p></p>\n", "parameters": ["sectionName", "key", "value"], "funcdef": "def"}, {"fullname": "configuration_class.Configuration.getConfigValue_cache", "modulename": "configuration_class", "qualname": "Configuration.getConfigValue_cache", "type": "function", "doc": "<p></p>\n", "parameters": ["sectionName", "key"], "funcdef": "def"}, {"fullname": "configuration_class.Configuration.setConfigValue_cache", "modulename": "configuration_class", "qualname": "Configuration.setConfigValue_cache", "type": "function", "doc": "<p></p>\n", "parameters": ["sectionName", "key", "value"], "funcdef": "def"}, {"fullname": "data_augmentation", "modulename": "data_augmentation", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_augmentation.mean_profile", "modulename": "data_augmentation", "qualname": "mean_profile", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Calculate mean profile of measurements within the recent x days\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>data : pd.DataFrame\n    data for calulating mean profile\n\nfrequency : str\n    frequency the data should have\n\ncolumn : str\n    target column to calculate mean profile for\n\nlook_back : str\n    days to consider for calculating profile\n\ndate : str\n    date to start mean profile calculating from\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>profile : pd.DataFrame\n    mean profile of data\n\nstd : float\n   standard deviation\n</code></pre>\n", "parameters": ["frequency", "column", "data", "look_back", "date", "nbins"], "funcdef": "def"}, {"fullname": "data_augmentation.generate_noise", "modulename": "data_augmentation", "qualname": "generate_noise", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Generate some random noise based on standard deviation of data\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>length : int\n    length of sequence with random noise\n\nstd : int\n    standard deviation for random generator\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>samples : numpy.array\n    array of random generated noise\n</code></pre>\n", "parameters": ["length", "std"], "funcdef": "def"}, {"fullname": "data_augmentation.SampleFromDistribution", "modulename": "data_augmentation", "qualname": "SampleFromDistribution", "type": "function", "doc": "<p></p>\n", "parameters": ["prob", "values"], "funcdef": "def"}, {"fullname": "data_augmentation.augmentation", "modulename": "data_augmentation", "qualname": "augmentation", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Reconstruct missing values\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>data : pd.DataFrame\n    data to fill in missing values\n\nstart_time : str or datetime\n    start of time range of missing values\n\nend_time : str or datetime\n    end of time range of missing values\n\ncolumn : str\n    column to augment the data\n\nfrequency : str\n    frequency the data should have\n\nlook_back : str\n    look_back to calculate a mean profile as basis for augmentation\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>augmented_data : pd.DataFrame\n    data with missing values filled\n</code></pre>\n", "parameters": ["data", "start_time", "end_time", "column", "frequency", "look_back"], "funcdef": "def"}, {"fullname": "data_augmentation.data_augmentation", "modulename": "data_augmentation", "qualname": "data_augmentation", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Main function of the data augmentation which is used to fill missing values.\n</code></pre>\n\n<p>Idea</p>\n\n<pre><code>The idea is to calculate a mean profile based on recent x-days of measurement (currently 28 days).\nIn the current datasets there are no daily changes e.g. between weekday or weekend. Because of\nthat it is possible to simply use all data within this period. On this profile random noise is\napplied to avoid the algorithm of learning the exact same profile over and over again. By using\nrandom noise the algorithm has to filter the underlaying structure itself\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>dataset : pd.DataFrame\n    data to fill in missing values\n\nfrequency : str\n    frequency the data should have\n\ncolumn : str\n    column to fill missing values\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dataset : pd.DataFrame\n    dataset with filled missing values\n</code></pre>\n\n<p>Notes</p>\n\n<pre><code>If data set shows some sign of weekday seasonalities e.g. changes between weekend and weekday\nthe calculation of the mean profile has to be changed. An example of how this should be changed\nis shown in the PSLP.py which seperates the data concerning: weekday, weekend, holiday. If there\nare seasonal repetitions these have to be considered as well.\n</code></pre>\n", "parameters": ["dataset", "frequency", "column"], "funcdef": "def"}, {"fullname": "data_manager", "modulename": "data_manager", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_manager.DataManager", "modulename": "data_manager", "qualname": "DataManager", "type": "class", "doc": "<p>Managing Data</p>\n"}, {"fullname": "data_manager.DataManager.__init__", "modulename": "data_manager", "qualname": "DataManager.__init__", "type": "function", "doc": "<p>Attributes</p>\n\n<pre><code>data : pd.DataFrame\n    DataFrame with time series\n\ntz_info : str\n    str resembling timezone of time series\n\ntime_column_name : str\n    str which is name of time column\n\ntime_column_is_index : bool\n    bool to check if timecolumn is set as index\n\nlast_timestamp : datetime\n    datetime of last timestep in the dataset\n\ndata_frequency : str\n    str frequency the data should have\n\ntimes_with_many_missing_values : list\n    list of missing values [start ,end]\n</code></pre>\n", "parameters": ["self", "name"], "funcdef": "def"}, {"fullname": "data_manager.DataManager.delete_outliers_data_preprocessing_cache", "modulename": "data_manager", "qualname": "DataManager.delete_outliers_data_preprocessing_cache", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>delete outliers from preprocessed cached data\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>max : int\n    maximum value\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>data without outliers\n</code></pre>\n", "parameters": ["self", "max"], "funcdef": "def"}, {"fullname": "data_manager.DataManager.allow_updates", "modulename": "data_manager", "qualname": "DataManager.allow_updates", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Adds update manager\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>from_config : bool\n    True : load configuration from config file\n\nurl : str\n    url to get data from\n\ntimezone_server : str\n    timezone of server data\n\nconfig_section : str\n    section of config to get configuration from\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "from_config", "url", "timezone_server", "config_section"], "funcdef": "def"}, {"fullname": "data_manager.DataManager.load_cached_file", "modulename": "data_manager", "qualname": "DataManager.load_cached_file", "type": "function", "doc": "<p>loads cached data</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_manager.DataManager.read_config_from_file", "modulename": "data_manager", "qualname": "DataManager.read_config_from_file", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>read configuration from config\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>section : str\n    section in config where configuration is written\n\nfolder : str\n    folder to read config from\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>data is stored in class\n</code></pre>\n", "parameters": ["self", "section", "folder"], "funcdef": "def"}, {"fullname": "data_manager.DataManager.update_data", "modulename": "data_manager", "qualname": "DataManager.update_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>update data with manager\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current timestamp\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>received data\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "data_manager.DataManager.standardize_new_data", "modulename": "data_manager", "qualname": "DataManager.standardize_new_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>put new data in standard format\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_manager.DataManager.using_cumsum", "modulename": "data_manager", "qualname": "DataManager.using_cumsum", "type": "function", "doc": "<p>deprecated</p>\n", "parameters": ["self", "df", "change_resolution_to"], "funcdef": "def"}, {"fullname": "data_manager.DataManager.add_data", "modulename": "data_manager", "qualname": "DataManager.add_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>adds standardized new data to dataset\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>change_resolution_to : str or None\n    changes new data to another resolution\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>Data is stored in class\n</code></pre>\n", "parameters": ["self", "change_resolution_to"], "funcdef": "def"}, {"fullname": "data_manager.DataManager.resample_data_to_raw_frequency", "modulename": "data_manager", "qualname": "DataManager.resample_data_to_raw_frequency", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>resamples data to specified raw frequency\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>frequency : str\n    raw frequency\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>resampled data\n</code></pre>\n", "parameters": ["self", "frequency"], "funcdef": "def"}, {"fullname": "data_manager.DataManager.resample_data_to_raw_frequency_load", "modulename": "data_manager", "qualname": "DataManager.resample_data_to_raw_frequency_load", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Load data resampler to raw frequency\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>frequency : str\n    frequency of raw data\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None or resampled data\n</code></pre>\n", "parameters": ["self", "frequency"], "funcdef": "def"}, {"fullname": "data_manager.DataManager.save_cached_data", "modulename": "data_manager", "qualname": "DataManager.save_cached_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>save current data\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager", "modulename": "data_manager", "qualname": "WeatherDataManager", "type": "class", "doc": "<p>Function</p>\n\n<pre><code>A class which combines several basic functions for time series data\n</code></pre>\n\n<p>Attributes</p>\n\n<pre><code>data : pd.DataFrame\n    DataFrame with time series\n\ntz_info : str\n    str resembling timezone of time series\n\ntime_column_name : str\n    str which is name of time column\n\ntime_column_is_index : bool\n    bool to check if timecolumn is set as index\n\nlast_timestamp : datetime\n    datetime of last timestep in the dataset\n\ndata_frequency : str\n    str frequency the data should have\n\ntimes_with_many_missing_values : list\n    list of missing values [start ,end]\n</code></pre>\n"}, {"fullname": "data_manager.WeatherDataManager.__init__", "modulename": "data_manager", "qualname": "WeatherDataManager.__init__", "type": "function", "doc": "<p>Attributes</p>\n\n<pre><code>data : pd.DataFrame\n    DataFrame with time series\n\ntz_info : str\n    str resembling timezone of time series\n\ntime_column_name : str\n    str which is name of time column\n\ntime_column_is_index : bool\n    bool to check if timecolumn is set as index\n\nlast_timestamp : datetime\n    datetime of last timestep in the dataset\n\ndata_frequency : str\n    str frequency the data should have\n\ntimes_with_many_missing_values : list\n    list of missing values [start ,end]\n</code></pre>\n", "parameters": ["self", "name"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.allow_updates", "modulename": "data_manager", "qualname": "WeatherDataManager.allow_updates", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Adds update manager\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>from_config : bool\n    True : load configuration from config file\n\nurl : str\n    url to get data from\n\ntimezone_server : str\n    timezone of server data\n\nconfig_section : str\n    section of config to get configuration from\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "from_config", "url", "timezone_server", "config_section"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.load_cached_historical_data", "modulename": "data_manager", "qualname": "WeatherDataManager.load_cached_historical_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>loads cached historical weather data\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.load_cached_weather_forecast", "modulename": "data_manager", "qualname": "WeatherDataManager.load_cached_weather_forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>loads cached forecast weather data\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.load_cached_long_term_weather", "modulename": "data_manager", "qualname": "WeatherDataManager.load_cached_long_term_weather", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>loads cached NASA weather data\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.read_config_from_file", "modulename": "data_manager", "qualname": "WeatherDataManager.read_config_from_file", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>read configuration from config\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>current_path : str\n    path were config is situated\n</code></pre>\n", "parameters": ["self", "current_path"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.update_data", "modulename": "data_manager", "qualname": "WeatherDataManager.update_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>update data with manager\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>url_list : list\n    list of urls\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>data from server\n</code></pre>\n", "parameters": ["self", "url_list"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.standardize_new_data", "modulename": "data_manager", "qualname": "WeatherDataManager.standardize_new_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>put new data in standard format\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>load : bool\n    True if load data is standardized\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.add_data", "modulename": "data_manager", "qualname": "WeatherDataManager.add_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>adds standardized new data to dataset\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.resample_data_to_raw_frequency", "modulename": "data_manager", "qualname": "WeatherDataManager.resample_data_to_raw_frequency", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>resamples data to specified raw frequency\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>frequency : str\n    raw frequency\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>resampled data\n</code></pre>\n", "parameters": ["self", "frequency"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.save_cached_data", "modulename": "data_manager", "qualname": "WeatherDataManager.save_cached_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>save current data\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.check_weather_forecast_available", "modulename": "data_manager", "qualname": "WeatherDataManager.check_weather_forecast_available", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>checks if weather forecst available cached or on server\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>latest_forecast_data_link : str\n    URL\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>data or False\n</code></pre>\n", "parameters": ["self", "latest_forecast_data_link"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.load_weather_forecast", "modulename": "data_manager", "qualname": "WeatherDataManager.load_weather_forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>get weather forecat from server and pre-process\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>weather_forecast_data_link : str\n    link to weather forecat data on server\n</code></pre>\n\n<p>return</p>\n\n<pre><code>pre-processed weather forecast\n</code></pre>\n", "parameters": ["self", "weather_forecast_data_link"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.format_time_new_data", "modulename": "data_manager", "qualname": "WeatherDataManager.format_time_new_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Format time column of new data\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>data : pd.DataFrame\n    new data\n\ntime_column : str\n    time column in data\n\ntimezone : str\n    timezone of time data\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>data : pd.DataFrame\n    data with formated time data\n</code></pre>\n", "parameters": ["self", "data", "time_column", "timezone"], "funcdef": "def"}, {"fullname": "data_manager.WeatherDataManager.get_and_process_long_term_weather_data", "modulename": "data_manager", "qualname": "WeatherDataManager.get_and_process_long_term_weather_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Load NASA weather data\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : str\n    current timestamp\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "data_preparation", "modulename": "data_preparation", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_preparation.split_data_monthly", "modulename": "data_preparation", "qualname": "split_data_monthly", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Split data into monthly clusters and calculate statistics\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>dataset : pd.DataFrame\n    dataset to split\n\ntarget : str\n    name of target column\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>monthly_data : dict of pd.DataFrames\n    data sorted into month\n\nmonthly_statistics\n    total statistics of dataset\n</code></pre>\n", "parameters": ["dataset", "target"], "funcdef": "def"}, {"fullname": "data_preparation.sunshine_filter", "modulename": "data_preparation", "qualname": "sunshine_filter", "type": "function", "doc": "<p></p>\n", "parameters": ["dataset", "target"], "funcdef": "def"}, {"fullname": "data_preparation.check_if_missing_values_are_in_line", "modulename": "data_preparation", "qualname": "check_if_missing_values_are_in_line", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>check for missing values following each other\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>Checking if one or two datapoints are missing or more following each other. This is done by\nchecking the frequency which the data should have and the gap of missing values\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>day_time_data : pd.DataFrame\n    measurements during daytimes\n\ntarget : str\n    target column to check for inconsistencies\n\nfrequency : str\n    Frequency of raw data\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>boolean value if over 3 values are missing in a row\n</code></pre>\n\n<p>Notes</p>\n\n<pre><code>Smaller chunks of missing values can be reestimated by using linear interpolation or something\nelse. Then you have to be sure that no random dips or rises can be avaialble. Therefor the limit\nof missing values is set to a lower value: 3\n</code></pre>\n", "parameters": ["day_time_data", "target", "frequency"], "funcdef": "def"}, {"fullname": "data_preparation.fill_day_time_data", "modulename": "data_preparation", "qualname": "fill_day_time_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Fill missing values during daytimes. This is mostly for PV data\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>day_time_data : pd.DataFrame\n    measurements during daytimes\n\ntarget : str\n    target column to check for inconsistencies\n\nfrequency : str\n    Frequency of raw data\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>day_time_data : pd.DataFrame\n    repaired or unrepaired data\n\nunrepairable : bool\n    decision if data was repairable\n</code></pre>\n\n<p>Notes</p>\n\n<pre><code>data is filled polynomial because linear would create a sharp edge\n</code></pre>\n", "parameters": ["day_time_data", "target", "frequency"], "funcdef": "def"}, {"fullname": "data_preparation.check_for_days_with_large_amount_of_missing_values", "modulename": "data_preparation", "qualname": "check_for_days_with_large_amount_of_missing_values", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>General check up of datasets to get total amount of missing values per day\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>maximum_percentage : float\n    share of datapoints missing on a day\n\ndata : pd.DataFrame\n    data to check for missing values\n\nfrequency : str\n    frequency the data should have\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>days_to_drop : list of datetime.date\n    dates exceeding share of missing vales\n\nmissing_value_frame : pd.DataFrame\n    statistical DataFrame showing on which day how many values are missing and the share\n</code></pre>\n", "parameters": ["maximum_percentage", "data", "frequency"], "funcdef": "def"}, {"fullname": "data_preparation.fill_night_data", "modulename": "data_preparation", "qualname": "fill_night_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>During nighttime value of target column is set to 0\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>night_time_data : pd.DataFrame\n    Measurements during nighttime\n\ntarget : str\n    name of target columns\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>night_time_data : pd.DataFrame\n    DataFrame with target column set to 0\n</code></pre>\n", "parameters": ["night_time_data", "target"], "funcdef": "def"}, {"fullname": "data_preparation.fill_mv_potentialy", "modulename": "data_preparation", "qualname": "fill_mv_potentialy", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Vaguely try to fill missing values in PV data\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>Filling Missing Value in datasets. Data during nighttime is set to 0 for PV generation\nand daytime is checked if it is repairable and then repaired with polynomial interpolation\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>data : pd.DataFrame\n    data to fill missing vales\n\nsun_times : astral.location\n    sunrise and sunset from astral library\n\nfrequency : str\n    frequency in which data should be\n\ntarget : str\n    name of target column in dataset\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>data : pd.DataFrame\n    data with some of the missing values filled.\n</code></pre>\n", "parameters": ["data", "sun_times", "frequency", "target"], "funcdef": "def"}, {"fullname": "update_manager", "modulename": "update_manager", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "update_manager.UpdateManager", "modulename": "update_manager", "qualname": "UpdateManager", "type": "class", "doc": "<p></p>\n"}, {"fullname": "update_manager.UpdateManager.__init__", "modulename": "update_manager", "qualname": "UpdateManager.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "url", "timezone_server"], "funcdef": "def"}, {"fullname": "update_manager.UpdateManager.reformat_time", "modulename": "update_manager", "qualname": "UpdateManager.reformat_time", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>reformat time to URL usable time\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time: str or pd.datetime\n    current time to check for\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>converted time for URL\n</code></pre>\n", "parameters": ["self", "time", "format"], "funcdef": "def"}, {"fullname": "update_manager.UpdateManager.time_zone", "modulename": "update_manager", "qualname": "UpdateManager.time_zone", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "time"], "funcdef": "def"}, {"fullname": "update_manager.UpdateManager.build_url", "modulename": "update_manager", "qualname": "UpdateManager.build_url", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>build url to get data from server\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>start_time: None, str or pd.datetime\n\n    start date for data to get\n\nend_time: None, str or pd.datetime\n    end date for data to get\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>url to be send for request\n</code></pre>\n", "parameters": ["self", "start_time", "end_time"], "funcdef": "def"}, {"fullname": "update_manager.UpdateManager.multipage_parse", "modulename": "update_manager", "qualname": "UpdateManager.multipage_parse", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>parses data if multiple pages are available\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>full_url: str\n    url for data\n\nfirst_page: int\n    number of first page\n\nlast_page: int\n    number of last page\n\nsection_name: str\n    section where data is stored\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>parsed data\n</code></pre>\n", "parameters": ["self", "full_url", "first_page", "last_page", "section_name"], "funcdef": "def"}, {"fullname": "update_manager.UpdateManager.singlepage_parse", "modulename": "update_manager", "qualname": "UpdateManager.singlepage_parse", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>parses data from single url\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>parsed: json\n    parsed data\n\nsection_name: str\n    section where data is stored\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dataframe with parsed data\n</code></pre>\n", "parameters": ["self", "parsed", "section_name"], "funcdef": "def"}, {"fullname": "update_manager.UpdateManager.request_data", "modulename": "update_manager", "qualname": "UpdateManager.request_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>request data from server\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>start_time: datetime\n    last timestep available in data\n\ncurrent_time: datetime\n    current timestamp\n\nsection: str\n    section where data is stored\n\nreturn_exception_raised: bool\n    if exception should be retured\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>loaded data and exception\n</code></pre>\n", "parameters": ["self", "start_time", "current_time", "section", "return_exception_raised"], "funcdef": "def"}, {"fullname": "update_manager.UpdateManager.extract_urls", "modulename": "update_manager", "qualname": "UpdateManager.extract_urls", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>extract weather data urls\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>url_list: list\n    data to extract urls from\n\nsection_name: str\n    section where to extract data from\n\nurl_prefix: str\n    prefix to add to url\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>list of extracted urls\n</code></pre>\n", "parameters": ["self", "url_list", "section_name", "url_prefix"], "funcdef": "def"}, {"fullname": "update_manager.UpdateManager.request_historical_weather_data_from_server", "modulename": "update_manager", "qualname": "UpdateManager.request_historical_weather_data_from_server", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>get historical weather data from server\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>url_list: list\n    list of urls to get historical weather data from\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>historic weather data\n</code></pre>\n", "parameters": ["self", "url_list"], "funcdef": "def"}, {"fullname": "update_manager.UpdateManager.parse_forecast_data", "modulename": "update_manager", "qualname": "UpdateManager.parse_forecast_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>parse forecast data to dataframe\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>parsed: json\n    raw data\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>forecast_data\n</code></pre>\n", "parameters": ["self", "parsed"], "funcdef": "def"}, {"fullname": "update_manager.UpdateManager.request_forecast", "modulename": "update_manager", "qualname": "UpdateManager.request_forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>get forecast data from server\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>forecast_url : str\n    url to download forecast\n\nweather_forecast_path : str\n    path to save forecast\n\nweather_forecast_name\n    name of weather forecast\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>forecast data\n</code></pre>\n", "parameters": ["self", "forecast_url", "weather_forecast_path", "weather_forecast_name"], "funcdef": "def"}, {"fullname": "update_manager.UpdateManager.request_nasa", "modulename": "update_manager", "qualname": "UpdateManager.request_nasa", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>get data from NASA\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>lat: str\n    latitude of site\n\nlon : str\n    longitude of site\n\ntime_now : pd.datetime\n    current timestamp\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>data and exception\n</code></pre>\n", "parameters": ["self", "lat", "lon", "time_now", "start"], "funcdef": "def"}, {"fullname": "evaluation", "modulename": "evaluation", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "evaluation.calculate_metrics", "modulename": "evaluation", "qualname": "calculate_metrics", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>calculate evaluation metrics\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>eval_data : pd.DataFrame\n    data to calculate metrics for\nmeasurements : pd.DataFrame\n    recent measurements\ndate_time : str\n    date_time string when prediction was made\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>results : pd.DataFrame\n    evaluation results\n</code></pre>\n", "parameters": ["eval_data", "measurements", "date_time"], "funcdef": "def"}, {"fullname": "evaluation.ForecastEvaluation", "modulename": "evaluation", "qualname": "ForecastEvaluation", "type": "class", "doc": "<p>Function</p>\n\n<pre><code>Class to evaluate forecasts and gives recommendations to train\n</code></pre>\n\n<p>Methods</p>\n\n<pre><code>__read_recent_forecasts()\n    reading in all forecasts which were made\n\nevaluate_recent_forecasts\n    evaluates forecasts if data is available\n\n__eval_ml_retrain\n    checks if ml algorithms should be retrained\n\n__eval_ml_reset\n    checks if ml algorithms need a reset\n\n__eval_metrics\n    calculates metrices\n\nrecommend\n    recommends retrain, reset or to do nothing\n\nwrite_to_excel\n    writes predictions to excel for optimizer\n\nwrite_to_csv\n    saves prediction as csv\n</code></pre>\n\n<p>Attributes</p>\n\n<pre><code>recent_forecasts : dict with pd.DataFrame\n    calculated metrics of recent forecasts\n\nforecast_horizon : dict with strings\n    forecast horizons of long and short term forecasts\n\nfrequencies : dict with strings\n    data frequencies of long and short term forecasts\n\nrecommendation : dict\n    collected recommendations to retrain, reset or nothing\n\nsheet : dict\n    which excel sheet to put data in for optimizer\n\nexcel_path : str\n    path to excel file to put predictions in\n</code></pre>\n"}, {"fullname": "evaluation.ForecastEvaluation.__init__", "modulename": "evaluation", "qualname": "ForecastEvaluation.__init__", "type": "function", "doc": "<p>Attributes</p>\n\n<pre><code>recent_forecasts : dict with pd.DataFrame\n    calculated metrics of recent forecasts\n\nforecast_horizon : dict with strings\n    forecast horizons of long and short term forecasts\n\nfrequencies : dict with strings\n    data frequencies of long and short term forecasts\n\nrecommendation : dict\n    collected recommendations to retrain, reset or nothing\n\nsheet : dict\n    which excel sheet to put data in for optimizer\n\nexcel_path : str\n    path to excel file to put predictions in\n</code></pre>\n", "parameters": ["self", "folder"], "funcdef": "def"}, {"fullname": "evaluation.ForecastEvaluation.evaluate_recent_forecasts", "modulename": "evaluation", "qualname": "ForecastEvaluation.evaluate_recent_forecasts", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>evaluate forecasts for which data is available\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current timestamps\n\npart : str\n    part to evaluate\n\ncurrent_data : pd.DataFrame\n    all measurements available\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "time_now", "part", "current_data"], "funcdef": "def"}, {"fullname": "evaluation.ForecastEvaluation.recommend", "modulename": "evaluation", "qualname": "ForecastEvaluation.recommend", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Recommends to retrain, resets or nothing\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>Recommendation\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "evaluation.ForecastEvaluation.write_to_excel", "modulename": "evaluation", "qualname": "ForecastEvaluation.write_to_excel", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Writes predictions to excel for optimization\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>forecast : pd.DataFrame\n    all forecasts for part\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "forecasts", "time_now"], "funcdef": "def"}, {"fullname": "evaluation.ForecastEvaluation.write_to_csv", "modulename": "evaluation", "qualname": "ForecastEvaluation.write_to_csv", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Writes predictions to csv to store for further evaluation\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>forecasts : pd.DataFrame\n    all forecasts for part\n\ntime_now : datetime\n    current timestamp\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "forecasts", "time_now"], "funcdef": "def"}, {"fullname": "features", "modulename": "features", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "features.time_to_seconds", "modulename": "features", "qualname": "time_to_seconds", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>converts timestamps to time as seconds on different time scales (seconds to year)\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>time_data : pd.DataFrame\n    data with column (named: 'time') to calculate to seconds\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>time_data : DataFrame\n    data with time columns given in seconds\n</code></pre>\n", "parameters": ["time_data"], "funcdef": "def"}, {"fullname": "features.cyclic_time", "modulename": "features", "qualname": "cyclic_time", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Time representation as sine or cosine function\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>This is a positional encoding technique for algorithms showing when measurement was taken and when in forecast\nhorizon the prediction should be\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>dataset : pd.DataFrame or pd.Series\n    DataFrame with time data as index\n\nweek : bool\n    sine or cosine over a week\n\nday : bool\n    sine or cosine over a day\n\nhour : bool\n    sine or cosine over a hour\n\nyear : bool\n    sine or cosine over a year\n\nminute : bool\n    sine or cosine over a minute\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dataset : pd.DataFrame\n    data with selected sine and cosine representation\n</code></pre>\n", "parameters": ["dataset", "week", "day", "hour", "year", "minute"], "funcdef": "def"}, {"fullname": "features.last_days_max", "modulename": "features", "qualname": "last_days_max", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Derives maximum values of recent days to form a feature for ML-Algorithms\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>dataset : pd.DataFrame\n    data with target column\n\ntarget_column : str\n    name of target column\n\ndays : int\n    period to look for highest values\n\nfill_na : bool\n    activates filling na with 0\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dataset : initial pd.DataFrame\n    data with added features\n</code></pre>\n", "parameters": ["dataset", "target_column", "days", "fill_na"], "funcdef": "def"}, {"fullname": "features.add_weather_data", "modulename": "features", "qualname": "add_weather_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>adds weather prediction or historic data to given dataframe\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>data : pd.DataFrame\n    data to which weather data should be added\n\nhistoric : pd.DataFrame\n    datawith historical weather data\n\nforecast : pd.DataFrame\n    data with weather prediction\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>data : pd.DataFrame\n    data with added weather data\n</code></pre>\n", "parameters": ["data", "historic", "forecast"], "funcdef": "def"}, {"fullname": "features.prepare_long_term_weather", "modulename": "features", "qualname": "prepare_long_term_weather", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>shifts weather data several times to have recent 10 years of data per row\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>long_term_weather_data : pd.DataFrame\n    data with NASA weather data\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>data : pd.DataFrame\n    data with shifted weather data\n</code></pre>\n", "parameters": ["long_term_weather_data"], "funcdef": "def"}, {"fullname": "load_forecaster", "modulename": "load_forecaster", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "load_forecaster.LoadForecasting", "modulename": "load_forecaster", "qualname": "LoadForecasting", "type": "class", "doc": "<p></p>\n"}, {"fullname": "load_forecaster.LoadForecasting.__init__", "modulename": "load_forecaster", "qualname": "LoadForecasting.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pslp_var", "folder"], "funcdef": "def"}, {"fullname": "load_forecaster.LoadForecasting.load_all_data", "modulename": "load_forecaster", "qualname": "LoadForecasting.load_all_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>loads all needed data for load forecasting (Scaler, PSLP and Load Measurements)\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>pslp_var : bool\n    True : variable length PSLP is used\n    False: PSLP with all data is used\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "pslp_var"], "funcdef": "def"}, {"fullname": "load_forecaster.LoadForecasting.get_data_from_server", "modulename": "load_forecaster", "qualname": "LoadForecasting.get_data_from_server", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>request measurements from server\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current time\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>weather_links : pd.DataFrame\n    empty if no new weather data is available else links\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "load_forecaster.LoadForecasting.to_current_date", "modulename": "load_forecaster", "qualname": "LoadForecasting.to_current_date", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>augments data to current date if measurements are not coming in\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current timestamp\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>Data without missing values up to current timestamp\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "load_forecaster.LoadForecasting.preprocess_data", "modulename": "load_forecaster", "qualname": "LoadForecasting.preprocess_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>pre-process new data\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>Preprocess data\n    1. Outlier removal\n    2. missing values\n    3. save\n    4. save filled dataset\n    5. ready up pslp\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>Data is stored in class\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "load_forecaster.LoadForecasting.persistency_forecast", "modulename": "load_forecaster", "qualname": "LoadForecasting.persistency_forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>calculate persistency forecast\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current time\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>data with persistency forecast\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "load_forecaster.LoadForecasting.persistency_forecast_long", "modulename": "load_forecaster", "qualname": "LoadForecasting.persistency_forecast_long", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>calculate persistency forecast\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current time\n\n\nReturn\n\n    data with persistency forecast\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "load_forecaster.LoadForecasting.save_prediction", "modulename": "load_forecaster", "qualname": "LoadForecasting.save_prediction", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>saves prediction\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current time\ndata : pd.DataFrame\n    data to save\npart : str\n    either LF, weather or PV\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "time_now", "data", "part"], "funcdef": "def"}, {"fullname": "load_forecaster.LoadForecasting.add_statistical_forecasts_short", "modulename": "load_forecaster", "qualname": "LoadForecasting.add_statistical_forecasts_short", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>adding statistical forecasts like PSLP or persistency &amp; save prediction\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>ai_prediction : pd.DataFrame\n    prediction done by AI\ntime_now : datetime\n    current time\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>combined_forecast : pd.DataFrame\n    output of all short term prediction methods in one dataframe\n</code></pre>\n", "parameters": ["self", "ai_prediction", "time_now"], "funcdef": "def"}, {"fullname": "load_forecaster.LoadForecasting.add_statistical_forecasts_long", "modulename": "load_forecaster", "qualname": "LoadForecasting.add_statistical_forecasts_long", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>save prediction\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>ai_prediction : pd.DataFrame\n    prediction done by AI\ntime_now : datetime\n    current time\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>combined_forecast : pd.DataFrame\n    output of all long term prediction methods in one dataframe\n</code></pre>\n", "parameters": ["self", "ai_prediction", "time_now"], "funcdef": "def"}, {"fullname": "PSLP", "modulename": "PSLP", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "PSLP.calc_fast_PSLP", "modulename": "PSLP", "qualname": "calc_fast_PSLP", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Fast PSLP for Load Forecasting AI\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>data : pd.DataFrame\n    measured data\n\npslp_window : int\n    number of days to look back\n\n\nReturn\n\n    pslp\n</code></pre>\n", "parameters": ["data", "pslp_window"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile", "type": "class", "doc": "<p>Function</p>\n\n<pre><code>A class to calculate the Personalized Standardized Load Profile.\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>Personalized Standardized Load Profiles or short PSLP is one simple statistical approach to\nforecast future loads based on historical loads. The approach is a further development of the\nstandardized load profiles which were derived by \u201cVerband der Elektrizit\u00e4tswirtschaft e.V.\u201d\n(short: VDEW). The original profiles were derived by using measurements of 1209 different buildings\nbut with the uprising implementation of smart meters the basic rules were adopted and measured\ndata is used to derive suitable profiles for forecasting.\n\nIn the basic approach there are 11 profiles derived from the measured data. These are divided by\ntype of day (weekdays, Saturday, Sunday/vacation) and by season (transition, winter and summer).\n\nUsually public holidays are treated as a Sunday because load patterns are more equal to that then\nto a usual business day. Christmas and New Year\u2019s Day are an exception from that rule because these\ndays are treated as a Saturday if they are not on a Sunday.\n\nDuring preparation of the profiles measured data are sorted into the aforementioned categories.\nThen the profiles are calculated using the mean value of every point of time of time in the\nprofiles.\n\nFor the use in Mini-Grids the basic idea is used to generate a profile out of the measured data but\nthe approach is further adapted to the findings in the data of the Mini-Grid. In the data no weekly\nseasonality was found and every day looked more like the previous day. Therefore, this\ndifferentiation was omitted. Also, no clear annual effects of lower and higher loads were\ndetermined. Because of that the differentiation between seasons was also dropped. This leaves the\nidea of averaging measurements of recent days to form a load profile behind. This, by any means,\ndoes not mean that this approach is suitable for all Mini-Grids as this were the results of\nresearch conducted by now.\n</code></pre>\n\n<p>Attributes</p>\n\n<pre><code>target_column : str\n    name of column to predict\n\nholiday_times : list\n    can be filled then it is checked if a date is holiday. This is currently not implemented\n    as vacations were not found in measurements.\n\ndata_frequency : str\n    Frequency in which prediction should be done and incoming data is\n\ncache_dict : dict\n    storage for classified data\n\nlast_processed_timestep : pd.datetime\n    last timestep classified\n</code></pre>\n\n<p>Methods</p>\n\n<pre><code>__init_dicts()\n    inits storage dicts\n\n__vacation_dates()\n    get vacation dates\n\nget_season_info()\n    info on which season data is in\n\ncheck_for_christmas_new_year()\n    checks if date is christmas (currently set to always false)\n\ncheck_if_vacation()\n    checks if date is vacation (currently set to always false)\n\nget_day_info()\n    if day is weekday or Saturday or Sunday (currently set to always week)\n\nclassification_day()\n    gather all info to classify day\n    uses get_season_info() and get_day_info()\n\nsort_data_into_profile_cache()\n    sorts data into cache storages\n\npreprocess_new_data()\n    preprocesses new incoming data into classes\n\nround_up()\n    rounds up to next timestep\n\nget_previous_profile()\n    if correct profile is not available it uses previous one\n\nforecast()\n    forecasts future loads\n</code></pre>\n"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile.__init__", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile.__init__", "type": "function", "doc": "<p>Attributes</p>\n\n<pre><code>target_column : str\n    name of column to predict\n\nholiday_times : list\n    can be filled then it is checked if a date is holiday. This is currently not implemented\n    as vacations were not found in measurements.\n\ndata_frequency : str\n    Frequency in which prediction should be done and incoming data is\n\ncache_dict : dict\n    storage for classified data\n\nlast_processed_timestep : pd.datetime\n    last timestep classified\n</code></pre>\n", "parameters": ["self", "target_column"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile.get_season_info", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile.get_season_info", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>extract seasonal info from timestamp\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>date : pd.datetime\n    timestamp of measurement to be classified\n\nyear : str\n    year information of timestamp\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>season in which timestamp is\n</code></pre>\n", "parameters": ["self", "date", "year"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile.check_for_christmas_new_year", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile.check_for_christmas_new_year", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>checks if date is christmas\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>date : pd.datetime\n    timestamp of measurement to be classified\n\nyear : str\n    year information of timestamp\n\ndayofweek : str\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>deactivated -&gt; returns always 0\n</code></pre>\n", "parameters": ["self", "year", "date", "dayofweek"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile.check_if_vacation", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile.check_if_vacation", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>checks if date is christmas\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>date : pd.datetime\n    timestamp of measurement to be classified\n\nyear : str\n    year information of timestamp\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>deactivated -&gt; returns always 0\n</code></pre>\n", "parameters": ["self", "date"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile.get_day_info", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile.get_day_info", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>classify if day is weekday (w), saturday (sa) or sunday (su)\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>date : pd.datetime\n    timestamp of measurement to be classified\n\nyear : str\n    year information of timestamp\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>deactivated -&gt; returns always w\n</code></pre>\n", "parameters": ["self", "year", "date"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile.classification_day", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile.classification_day", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>find season and day type\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>date : pd.datetime\n    timestamp of measurement to be classified\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>season and day_info : str\n</code></pre>\n", "parameters": ["self", "date"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile.sort_data_into_profile_cache", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile.sort_data_into_profile_cache", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>sort day into cache to be able to make profiles\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>profile : pd.DataFrame\n    profile to sort data in\n\ndata_on_date : pd.DataFrame\n    data measured on date\n\ndate : pd.datetime\n    timestamp of measurement to be classified\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>Return is stored in class\n</code></pre>\n", "parameters": ["self", "profile", "data_on_date", "date"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile.preprocess_new_data", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile.preprocess_new_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>process new data into data cache\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>incoming_data : pd.DataFrame\n    new measured data\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>Return is stored in class\n</code></pre>\n", "parameters": ["self", "incoming_data"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile.round_up", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile.round_up", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : pd.datetime\n    current timestamp\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>rounded time\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile.get_previous_profile", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile.get_previous_profile", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>if there is no data in the profile for current season, use values of the last season as a guess\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>season : str\n    classified season\n\ndate : str\n    date of measurement\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>name of previous profile\n</code></pre>\n", "parameters": ["self", "season", "date"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile.forecast", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile.forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Forecasting\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : pd.datetime\n    current timestamp\n\nforecast_horizon : str\n    horizon length on which predictions should be made\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>forecast as pd.DataFrame\n</code></pre>\n", "parameters": ["self", "time_now", "forecast_horizon"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile_variable_length", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile_variable_length", "type": "class", "doc": "<p>Function</p>\n\n<pre><code>A class to calculate the Personalized Standardized Load Profile.\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>Personalized Standardized Load Profiles or short PSLP is one simple statistical approach to\nforecast future loads based on historical loads. The approach is a further development of the\nstandardized load profiles which were derived by \u201cVerband der Elektrizit\u00e4tswirtschaft e.V.\u201d\n(short: VDEW). The original profiles were derived by using measurements of 1209 different buildings\nbut with the uprising implementation of smart meters the basic rules were adopted and measured\ndata is used to derive suitable profiles for forecasting.\n\nIn the basic approach there are 11 profiles derived from the measured data. These are divided by\ntype of day (weekdays, Saturday, Sunday/vacation) and by season (transition, winter and summer).\n\nUsually public holidays are treated as a Sunday because load patterns are more equal to that then\nto a usual business day. Christmas and New Year\u2019s Day are an exception from that rule because these\ndays are treated as a Saturday if they are not on a Sunday.\n\nDuring preparation of the profiles measured data are sorted into the aforementioned categories.\nThen the profiles are calculated using the mean value of every point of time of time in the\nprofiles.\n\nFor the use in Mini-Grids the basic idea is used to generate a profile out of the measured data but\nthe approach is further adapted to the findings in the data of the Mini-Grid. In the data no weekly\nseasonality was found and every day looked more like the previous day. Therefore, this\ndifferentiation was omitted. Also, no clear annual effects of lower and higher loads were\ndetermined. Because of that the differentiation between seasons was also dropped. This leaves the\nidea of averaging measurements of recent days to form a load profile behind. This, by any means,\ndoes not mean that this approach is suitable for all Mini-Grids as this were the results of\nresearch conducted by now.\n\nThis class has an extension compared to the normal PSLP which is that it tries to estimate best\nlength of window size (starting at 1 Day going back to 31Days). This can increase forecast\naccuracy when days are more or less fluctuating without a specific pattern.\n</code></pre>\n\n<p>Attributes</p>\n\n<pre><code>target_column : str\n    name of column to predict\n\nholiday_times : list\n    can be filled then it is checked if a date is holiday. This is currently not implemented\n    as vacations were not found in measurements.\n\ndata_frequency : str\n    Frequency in which prediction should be done and incoming data is\n\ncache_dict : dict\n    storage for classified data\n\nlast_processed_timestep : pd.datetime\n    last timestep classified\n</code></pre>\n\n<p>Methods</p>\n\n<pre><code>__init_dicts()\n    inits storage dicts\n\n__vacation_dates()\n    get vacation dates\n\nget_season_info()\n    info on which season data is in\n\ncheck_for_christmas_new_year()\n    checks if date is christmas (currently set to always false)\n\ncheck_if_vacation()\n    checks if date is vacation (currently set to always false)\n\nget_day_info()\n    if day is weekday or Saturday or Sunday (currently set to always week)\n\nclassification_day()\n    gather all info to classify day\n    uses get_season_info() and get_day_info()\n\nsort_data_into_profile_cache()\n    sorts data into cache storages\n\npreprocess_new_data()\n    preprocesses new incoming data into classes\n\nround_up()\n    rounds up to next timestep\n\nget_previous_profile()\n    if correct profile is not available it uses previous one\n\nforecast()\n    forecasts future loads\n</code></pre>\n"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile_variable_length.__init__", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile_variable_length.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "target_column"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile_variable_length.get_day_info", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile_variable_length.get_day_info", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>classify if day is weekday (w), saturday (sa) or sunday (su)\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>date : pd.datetime\n    timestamp of measurement to be classified\n\nyear : str\n    year information of timestamp\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>deactivated -&gt; returns always w\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile_variable_length.classification_day", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile_variable_length.classification_day", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>find season and day type\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>date : pd.datetime\n    timestamp of measurement to be classified\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>season and day_info : str\n</code></pre>\n", "parameters": ["self", "date"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile_variable_length.sort_data_into_profile_cache", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile_variable_length.sort_data_into_profile_cache", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>sort day into cache to be able to make profiles\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>profile : pd.DataFrame\n    profile to sort data in\n\ndata_on_date : pd.DataFrame\n    data measured on date\n\ndate : pd.datetime\n    timestamp of measurement to be classified\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>Return is stored in class\n</code></pre>\n", "parameters": ["self", "data_on_date", "date"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile_variable_length.preprocess_new_data", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile_variable_length.preprocess_new_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>process new data into data cache\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>incoming_data : pd.DataFrame\n    new measured data\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>Return is stored in class\n</code></pre>\n", "parameters": ["self", "incoming_data"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile_variable_length.round_up", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile_variable_length.round_up", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : pd.datetime\n    current timestamp\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>rounded time\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile_variable_length.forecast_standard", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile_variable_length.forecast_standard", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Forecasting\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : pd.datetime\n    current timestamp\n\nforecast_horizon : str\n    horizon length on which predictions should be made\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>forecast as pd.DataFrame\n</code></pre>\n", "parameters": ["self", "time_now", "forecast_horizon"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile_variable_length.forecast_fixed_recency", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile_variable_length.forecast_fixed_recency", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Forecasting with a pre set recency\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : pd.datetime\n    current timestamp\n\nforecast_horizon : str\n    horizon length on which predictions should be made\n\nfixed_recency : int\n    days of data used for calculating PSLP\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>forecast as pd.DataFrame\n</code></pre>\n", "parameters": ["self", "time_now", "forecast_horizon", "fixed_recency"], "funcdef": "def"}, {"fullname": "PSLP.PersonalizedStandardizedLoadProfile_variable_length.forecast", "modulename": "PSLP", "qualname": "PersonalizedStandardizedLoadProfile_variable_length.forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Forecasting with variable length recency\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : pd.datetime\n    current timestamp\n\nforecast_horizon : str\n    horizon length on which predictions should be made\n\ntesting_length : int\n    sets maximum days to test to find best recency\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>forecast as pd.DataFrame\n</code></pre>\n", "parameters": ["self", "time_now", "forecast_horizon", "testing_length"], "funcdef": "def"}, {"fullname": "pv_forecaster", "modulename": "pv_forecaster", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "pv_forecaster.supervised_data_pv_long_term", "modulename": "pv_forecaster", "qualname": "supervised_data_pv_long_term", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Algorithm for long term PV forecast needs special data format shown under principle\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>preprocessed_long_weather : pd.DataFrame\n    data with NASA weather data\n\ndataset_with_horizon : pd.DataFrame\n    prolonged data, data with forecast horizon\n\nforecast_mode : bool\n    if true scaler is not refitted\n\nscaler : scaler\n    scaler used to scale data\n\ntime_now : datetime\n    current timestamp\n\nsplit : float\n    split data into train and test data for training\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dict with train, val and forecast data\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>Dataset has to be in a 3D Shape with [Samples, Timestep, Features]\nSmall Example:\n\nRaw Dataset Sample:\nTimestamp| Target | Feature 1 | Feature 2 |\n-------------------------------------------\nT1       | M1     | F1(T1)  | F2(T1)      |\nT2       | M2     | F1(T2)  | F2(T2)      |\nT3       | M3     | F1(T3)  | F2(T3)      |\n...      | ...    | ...     | ...         |\n\n3 Datasets are needed:\nTrain_x, Train_y, Forecast_x\n\nTrain_x contains all features or observations describing target measurement at specific timestamp\nTrain_y contains all data which are the target measurements\nforecast_x is the same as train_x with only values used for future observations\n\nFor long term PV:\nTrain_x consists of weather variables of NASA Dataset (shape: [varying, 24*90 = 2160, 90 (which is feature 1-90)]\nTrain_y are the PV measurements [varying, 2160, 1 (which is target)]\nForecast_x weather variables NASA Dataset over future hours [1, 2160, 90 (which is feature 1-90)]\n\nthere is also a Split of train_x and train_y into train and val data. e.g. 0.9 of the data are in train and 0.1 in val\n</code></pre>\n", "parameters": ["preprocessed_long_weather", "dataset_with_horizon", "forecast_mode", "scaler", "time_now", "split"], "funcdef": "def"}, {"fullname": "pv_forecaster.split_short_term_dataset", "modulename": "pv_forecaster", "qualname": "split_short_term_dataset", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>splitting data into train and forecast\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>dataset : pd.DataFrame\n    dataset to split\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>train_x : pd.DataFrame\n    trainingdataset with features\n\ntrain_y : pd.DataFrame or pd.Series\n    training dataset containing measurements\n\nforecast_x : pd.DataFrame\n    forecast dataset with features\n</code></pre>\n", "parameters": ["dataset"], "funcdef": "def"}, {"fullname": "pv_forecaster.PVForecasting", "modulename": "pv_forecaster", "qualname": "PVForecasting", "type": "class", "doc": "<p>Function</p>\n\n<pre><code>Class for PV Forecasting\n</code></pre>\n\n<p>Attributes</p>\n\n<pre><code>forecasting_mode : bool\n    only forecasting or also training\n\ndm : class\n    DataManager containing PV measurements\n\ndataset_short_term_forecast : None or pd.DataFrame or dict\n    dataset prepared for short term load forecast\n\ndataset_long_term_forecast : pd.DataFrame or dict\n    dataset prepared for long term load forecast\n\ntrick : Bool\n    Pushes dataset together (NOT RECOMMENDED! but data was limited)\n\nsun_times : astral.suntimes\n    timepoints of sunset and sunrise\n\nfilled_dataset : pd.DataFrame\n    dataset with nan filled (if possible)\n\nscaler_pv_short : class scaler\n    scaler for short term forecasting\n\nscaler_pv_long : class scaler\n    scaler for long term forecasting\n</code></pre>\n\n<p>Methods</p>\n\n<pre><code>get_data_from_server()\n    request measurements from server\n\npreprocess_data\n    preprocessed data e.g. missing values\n\ncreate_dataset_short_term_forecast\n    prepare dataset for short term forecasting\n\npersistency_forecast\n    calculate persistency forecast\n\ncreate_dataset_long_term_forecast\n    prepare dataset for long term forecasting\n\nsave_prediction\n    saves prediction\n\nadd_statistical_forecasts_short\n    adds statistical forecast e.g. pv power max last 5 days\n\nadd_statistical_forecasts_long\n    adds currently Nothing\n</code></pre>\n"}, {"fullname": "pv_forecaster.PVForecasting.__init__", "modulename": "pv_forecaster", "qualname": "PVForecasting.__init__", "type": "function", "doc": "<p>Attributes</p>\n\n<pre><code>forecasting_mode : bool\n    only forecasting or also training\n\ndm : class\n    DataManager containing PV measurements\n\ndataset_short_term_forecast : None or pd.DataFrame or dict\n    dataset prepared for short term load forecast\n\ndataset_long_term_forecast : pd.DataFrame or dict\n    dataset prepared for long term load forecast\n\ntrick : Bool\n    Pushes dataset together (NOT RECOMMENDED! but data was limited)\n\nsun_times : astral.suntimes\n    timepoints of sunset and sunrise\n\nfilled_dataset : pd.DataFrame\n    dataset with nan filled (if possible)\n\nscaler_pv_short : class scaler\n    scaler for short term forecasting\n\nscaler_pv_long : class scaler\n    scaler for long term forecasting\n</code></pre>\n", "parameters": ["self", "sun_times", "folder"], "funcdef": "def"}, {"fullname": "pv_forecaster.PVForecasting.load_all_data", "modulename": "pv_forecaster", "qualname": "PVForecasting.load_all_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>loads all needed data for load forecasting (Scaler, PSLP and Load Measurements)\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pv_forecaster.PVForecasting.get_data_from_server", "modulename": "pv_forecaster", "qualname": "PVForecasting.get_data_from_server", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>request measurements from server\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current time\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>weather_links : pd.DataFrame\n    empty if no new weather data is available else links\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "pv_forecaster.PVForecasting.preprocess_data", "modulename": "pv_forecaster", "qualname": "PVForecasting.preprocess_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Pre-Process data\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>1. Outlier removal\n2. missing values\n3. save\n4. try to fill missing values\n5. save filled dataset\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None return is stored in class\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pv_forecaster.PVForecasting.create_dataset_short_term_forecast", "modulename": "pv_forecaster", "qualname": "PVForecasting.create_dataset_short_term_forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>prepare dataset for short term forecasting\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current time\n\nhistorical_weather_data : pd.DataFrame\n    historical weather data collected\n\nforecast_data : pd.DataFrame\n    weather forecasts from OWM\n\nforecast_mode : bool\n    if scaler is refittet or not\n\nsplit : float [0, 1]\n    split of validation and training\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dataset_short_term_forecast : dict with tensors\n    train, val, forecast datasets\n</code></pre>\n", "parameters": ["self", "time_now", "historical_weather_data", "forecast_data", "forecast_mode", "split"], "funcdef": "def"}, {"fullname": "pv_forecaster.PVForecasting.persistency_forecast", "modulename": "pv_forecaster", "qualname": "PVForecasting.persistency_forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>calculate persistency forecast\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current time\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>Persistency Forecast\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "pv_forecaster.PVForecasting.persistency_forecast_long", "modulename": "pv_forecaster", "qualname": "PVForecasting.persistency_forecast_long", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>calculate persistency forecast\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current time\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>Persistency Forecast\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "pv_forecaster.PVForecasting.create_dataset_long_term_forecast", "modulename": "pv_forecaster", "qualname": "PVForecasting.create_dataset_long_term_forecast", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>prepare dataset for long term forecasting\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current time\n\nlong_term_weather_data : pd.DataFrame\n    NASA long term weather data\n\nforecast_mode : bool\n    if forecast mode is activated\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dataset_long_term_forecast : dict of tensors\n    train, val, forecast datasets\n</code></pre>\n", "parameters": ["self", "time_now", "long_term_weather_data", "forecast_mode"], "funcdef": "def"}, {"fullname": "pv_forecaster.PVForecasting.save_prediction", "modulename": "pv_forecaster", "qualname": "PVForecasting.save_prediction", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>saves prediction\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>time_now : datetime\n    current\n\ndata : pd.DataFrame\n    data to save\n\npart : str\n    either LF, weather or PV\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "time_now", "data", "part"], "funcdef": "def"}, {"fullname": "pv_forecaster.PVForecasting.correct_ai_prediction", "modulename": "pv_forecaster", "qualname": "PVForecasting.correct_ai_prediction", "type": "function", "doc": "<p>:param ai_prediction:\n:return:</p>\n", "parameters": ["self", "ai_prediction"], "funcdef": "def"}, {"fullname": "pv_forecaster.PVForecasting.add_statistical_forecasts_short", "modulename": "pv_forecaster", "qualname": "PVForecasting.add_statistical_forecasts_short", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>adding statistical forecasts like last days max or persistency &amp; save prediction\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>ai_prediction : pd.DataFrame\n    prediction done by AI\n\ntime_now : datetime\n    current time\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>combined_forecast : pd.DataFrame\n    output of all short term prediction methods in one dataframe\n</code></pre>\n", "parameters": ["self", "ai_prediction", "time_now"], "funcdef": "def"}, {"fullname": "pv_forecaster.PVForecasting.add_statistical_forecasts_long", "modulename": "pv_forecaster", "qualname": "PVForecasting.add_statistical_forecasts_long", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>save prediction\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>ai_prediction : pd.DataFrame\n    prediction done by AI\n\ntime_now : datetime\n    current time\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>combined_forecast : pd.DataFrame\n    output of all long term prediction methods in one dataframe\n</code></pre>\n", "parameters": ["self", "ai_prediction", "time_now"], "funcdef": "def"}, {"fullname": "scaling", "modulename": "scaling", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "scaling.Scaler", "modulename": "scaling", "qualname": "Scaler", "type": "class", "doc": "<p></p>\n"}, {"fullname": "scaling.Scaler.__init__", "modulename": "scaling", "qualname": "Scaler.__init__", "type": "function", "doc": "<p>Attribute</p>\n\n<pre><code> name: str\n    load or pv as name\n\n folder: str\n    foldername\n\nforecasting_mode: Bool\n    Only Forecasting should be done (Scaler is not refit)\n</code></pre>\n", "parameters": ["self", "folder", "name", "forecasting_mode"], "funcdef": "def"}, {"fullname": "scaling.Scaler.check_scaler_available", "modulename": "scaling", "qualname": "Scaler.check_scaler_available", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>check if already fitted scaler are available and load them if available\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "scaling.Scaler.scaler_fit", "modulename": "scaling", "qualname": "Scaler.scaler_fit", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>fit scaler to data\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>dataset_x: pd.DataFrame\n    dataset for descriptive features\n\ndataset_y: pd.DataFrame\n    dataset for target features\n\nsave: bool\n    save fitted scaler\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>trained scaler for x and y\n</code></pre>\n", "parameters": ["self", "dataset_x", "dataset_y", "save"], "funcdef": "def"}, {"fullname": "scaling.Scaler.scaler_transform", "modulename": "scaling", "qualname": "Scaler.scaler_transform", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>scale dataset\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>dataset_x: pd.DataFrame\n    dataset for descriptive features\n\ndataset_y: pd.DataFrame\n    dataset for target features\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>scaled datasets\n</code></pre>\n", "parameters": ["self", "dataset_x", "dataset_y"], "funcdef": "def"}, {"fullname": "scaling.Scaler.inverse_transform_prediction", "modulename": "scaling", "qualname": "Scaler.inverse_transform_prediction", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>rescale prediction\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>prediction: array\n    AI forecasts\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>rescaled prediction\n</code></pre>\n", "parameters": ["self", "prediction"], "funcdef": "def"}, {"fullname": "scaling.Scaler.scaler_transform_for_prediction", "modulename": "scaling", "qualname": "Scaler.scaler_transform_for_prediction", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>transforms dataset for AI prediction\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>dataset_x : array\n    dataset with features for forecasting stored\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>scaled dataset for forecasting\n</code></pre>\n", "parameters": ["self", "dataset_x"], "funcdef": "def"}, {"fullname": "scaling.Scaler.set_index", "modulename": "scaling", "qualname": "Scaler.set_index", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>store index\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>index: pd.Series\n    Series containing original index\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "index"], "funcdef": "def"}, {"fullname": "scaling.Scaler_pv_long", "modulename": "scaling", "qualname": "Scaler_pv_long", "type": "class", "doc": "<p></p>\n"}, {"fullname": "scaling.Scaler_pv_long.__init__", "modulename": "scaling", "qualname": "Scaler_pv_long.__init__", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>PV Long has special scaling needs most parts are close to normal scaler but with\nsome special extensions\n</code></pre>\n\n<p>Attribute</p>\n\n<pre><code>name: str\n    load or pv as name\n\nforecasting_mode: Bool\n    Only Forecasting should be done (Scaler is not refit)\n</code></pre>\n", "parameters": ["self", "name", "forecasting_mode"], "funcdef": "def"}, {"fullname": "scaling.Scaler_pv_long.check_scaler_available", "modulename": "scaling", "qualname": "Scaler_pv_long.check_scaler_available", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>check if already fitted scaler are available and load them if available\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "scaling.Scaler_pv_long.scaler_fit", "modulename": "scaling", "qualname": "Scaler_pv_long.scaler_fit", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>fit scaler to data\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>dataset_x: pd.DataFrame\n    dataset for descriptive features\n\ndataset_y: pd.DataFrame\n    dataset for target features\n\ndataset_long: pd.DataFrame\n    dataset containing special long term variables\n\nsave: bool\n    save fitted scaler\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>trained scaler for x and y\n</code></pre>\n", "parameters": ["self", "dataset_x", "dataset_y", "dataset_long", "save"], "funcdef": "def"}, {"fullname": "scaling.Scaler_pv_long.scaler_transform", "modulename": "scaling", "qualname": "Scaler_pv_long.scaler_transform", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>scale dataset\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>dataset_x: pd.DataFrame\n    dataset for descriptive features\n\ndataset_y: pd.DataFrame\n    dataset for target features\n\ndataset_long: pd.DataFrame\n    dataset containing special long term variables\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>scaled datasets\n</code></pre>\n", "parameters": ["self", "dataset_x", "dataset_y", "dataset_long"], "funcdef": "def"}, {"fullname": "scaling.Scaler_pv_long.inverse_transform_prediction", "modulename": "scaling", "qualname": "Scaler_pv_long.inverse_transform_prediction", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>rescale prediction\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>prediction: array\n    AI forecasts\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>rescaled prediction\n</code></pre>\n", "parameters": ["self", "prediction"], "funcdef": "def"}, {"fullname": "scaling.Scaler_pv_long.scaler_transform_for_prediction", "modulename": "scaling", "qualname": "Scaler_pv_long.scaler_transform_for_prediction", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>transforms dataset for AI prediction\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>dataset_x : array\n    dataset with features for forecasting stored\n\ndataset_long: pd.DataFrame\n    dataset containing special long term variables\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>scaled dataset for forecasting\n</code></pre>\n", "parameters": ["self", "dataset_x", "dataset_long"], "funcdef": "def"}, {"fullname": "forecasting_functions", "modulename": "forecasting_functions", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "forecasting_functions.round_up", "modulename": "forecasting_functions", "qualname": "round_up", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>find next timestep which is regular (e.g. 16:56:59 -&gt; 17:00:00)\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>time_now:  datetime\n    time to round up\n\ndata_frequency : str\n    to which frequency should be rounded\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>time_now_round : datetime\n    rounded datetime\n</code></pre>\n", "parameters": ["time_now", "data_frequency"], "funcdef": "def"}, {"fullname": "forecasting_functions.check_for_missing_values", "modulename": "forecasting_functions", "qualname": "check_for_missing_values", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>check dataset for missing values\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>data : pd.DataFrame\n    data to evaluate\n\ntime_now : datetime\n    last timestamp or current time\n\nfrequency : str\n    frequency of data\n\naugment : bool\n    fill na by auugmentation\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>filled data\n</code></pre>\n", "parameters": ["data", "time_now", "frequency", "augment"], "funcdef": "def"}, {"fullname": "forecasting_functions.prepare_dataset_for_forecasting", "modulename": "forecasting_functions", "qualname": "prepare_dataset_for_forecasting", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>prepare dataset for forecasting by extending index until end of forecast_horizon\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>data : pd.DataFrame\n    data to extend\n\nforecast_horizon : str\n    forecast horizon\n\nfrequency : str\n    frequency of data\n\ntime_now : str\n    current timestep\n\nrepair_missing_values : bool\n    repairs missing values with either augmentation or interpolation\n\naugment : bool\n    augment data or interpolate\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>data : pd.DataFrame\n    prolonged dataset\n</code></pre>\n", "parameters": ["data", "forecast_horizon", "frequency", "time_now", "repair_missing_values", "augment"], "funcdef": "def"}, {"fullname": "timeseriesfunctions", "modulename": "timeseriesfunctions", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame", "type": "class", "doc": "<p>Function</p>\n\n<pre><code>A class which combines several basic functions for time series data\n</code></pre>\n\n<p>Attributes</p>\n\n<pre><code>data : pd.DataFrame\n    DataFrame with time series\n\ntz_info : str\n    str resembling timezone of time series\n\ntime_column_name : str\n    str which is name of time column\n\ntime_column_is_index : bool\n    bool to check if timecolumn is set as index\n\nlast_timestamp : datetime\n    datetime of last timestep in the dataset\n\ndata_frequency : str\n    str frequency the data should have\n\ntimes_with_many_missing_values : list\n    list of missing values [start ,end]\n</code></pre>\n"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.__init__", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.__init__", "type": "function", "doc": "<p>Attributes</p>\n\n<pre><code>data : pd.DataFrame\n    DataFrame with time series\n\ntz_info : str\n    str resembling timezone of time series\n\ntime_column_name : str\n    str which is name of time column\n\ntime_column_is_index : bool\n    bool to check if timecolumn is set as index\n\nlast_timestamp : datetime\n    datetime of last timestep in the dataset\n\ndata_frequency : str\n    str frequency the data should have\n\ntimes_with_many_missing_values : list\n    list of missing values [start ,end]\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.delete_outliers", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.delete_outliers", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Deleting values between a range of min and max.\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>min: float\n    lower limit\n\nmax: float\n    upper limit\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>data: pd.DataFrame\n    data with values in the range of min and max\n</code></pre>\n", "parameters": ["self", "min", "max"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.check_for_double_values", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.check_for_double_values", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Check for indexes which are double in self.data\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.set_dataset_frequency", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.set_dataset_frequency", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>changes attribute data_frequency and reindex data if wanted to specified frequency\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>frequency : str\n    frequency which the data should have or has\n\nreindex : bool\n    reindex timeseries to specified frequency\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "frequency", "reindex"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.load_data_from_csv", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.load_data_from_csv", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>load data from a csv file and set as self.data\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>path : str\n    path to csv file\n\nsep : str\n    sign for value separation in file\n\nnames : list of str\n    names of columns\n\nindex_col : str\n    column name which should be set as index\n\nheader : str\n    header information\n\ndelimiter : str\n    Alias for sep\n\ndecimal : str\n    sign for differentiation between decimal and full number\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "path", "sep", "names", "index_col", "header", "delimiter", "decimal"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.update_last_timestamp", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.update_last_timestamp", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>update attribute last_timestamp manually\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.combine_two_str_columns", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.combine_two_str_columns", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>add two string columns and add them as a new column\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>column_names : list of str\n    column names to combine\n\nname_new_column : str\n    column name to put aggregated columns in\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Errors</p>\n\n<pre><code>TypeError for column_names if not iterable\n</code></pre>\n", "parameters": ["self", "column_names", "name_new_column"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.format_time_column", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.format_time_column", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Converts time column to pd.datetime including timezone information\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>column_name : str\n    name of time column\n\ntimezone : str\n    timezone of time series\n\nfrequency : str\n    raw frequency of time series\n\nexternal_date_data : pd.Series\n    external date data if not in data\n\nformat : str\n    format of datetime\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "column_name", "timezone", "frequency", "external_date_data", "format"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.localize_time_column", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.localize_time_column", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Localize time column and optionally set it as index\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>timezone : str\n    timezone to localize time series\n\ncolumn : str\n    column of timestamp\n\nset_index : bool\n    if time should be set as index\n\nexternal_date_data : pd.Series\n    external date data if not in data\n\nkeep_time_column : bool\n    keep time column as seperate column if set as index\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "timezone", "column", "set_index", "external_date_data", "keep_time_column"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.convert_timezone", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.convert_timezone", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Convert specified datetime column to specified timezone. Optionally: set as index\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>timezone : str\n    timezone to convert to\n\ncolumn : str\n    column name with time data\n\nset_index : bool\n    set converted timeline to index\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "timezone", "column", "set_index"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.column_to_index", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.column_to_index", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>set column to index\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>column : str\n    column_name\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "column"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.resample_data", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.resample_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>resample data to specified frequency\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>frequency : str\n    frequency to set data to\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "frequency"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.save_data", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.save_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>save_data to path/filename\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>path : str\n    path to directory\n\nfilename : str\n    filename of savefile\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "path", "filename"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.data_in_period", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.data_in_period", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>returns data from dataset between start and end\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>start : datetime\n    start timestamp\n\nend : datetime\n    end timestamp\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>data : pd.DataFrame\n    data in period\n</code></pre>\n", "parameters": ["self", "start", "end"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.make_dir", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.make_dir", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>makes directory\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>path : str\n    path of directory to be made\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "path"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.acf_plotter", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.acf_plotter", "type": "function", "doc": "<p>plotts autocorrelationfunction</p>\n\n<h2 id=\"parameter\">Parameter</h2>\n\n<h2 id=\"return\">Return</h2>\n", "parameters": ["self", "columns", "save_plot", "show_plot", "save_path", "nlags", "fft", "alpha"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.pacf_plotter", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.pacf_plotter", "type": "function", "doc": "<p>plots partial autocorrelation function</p>\n\n<h2 id=\"parameter\">Parameter</h2>\n\n<h2 id=\"return\">Return</h2>\n", "parameters": ["self", "columns", "save_plot", "show_plot", "save_path", "nlags", "method", "alpha"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.calculate_correlation", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.calculate_correlation", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>calculates correlation of data columns\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>method : str\n    method to be used to evaluate correlation\n\nmin_periods : int\n\nplot : bool\n    if heatmap should be plotted\n\nsave : bool\n    save result as csv\n\nsave_path : str\n    path to save results\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>plot\n</code></pre>\n", "parameters": ["self", "method", "min_periods", "plot", "save", "save_path"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.downscale_time", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.downscale_time", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>downscales time to another frequency e.g. 15 min to 1H\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>frequency : str\n    frequency to switch timeseries to\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "frequency"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.upscale_time", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.upscale_time", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>upscales data using specified interpolation_method e.g. from 1H to 15 min\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>frequency : str\n    frequency to switch timeseries to\n\ninterpolation_method : str\n    method to interpolate between data points\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "frequency", "interpolation_method"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.return_data_in_period", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.return_data_in_period", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "current_time", "start_date"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.show_missing_values", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.show_missing_values", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>checks for missing value and gives out statistics\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>external_data : pd.DataFrame\n    data to check\n\nfrequency_raw_data : str\n    frequency the data should have\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>diff : int\n    missing value count\n</code></pre>\n", "parameters": ["self", "external_data", "frequency_raw_data"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.check_for_days_with_large_amount_of_missing_values", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.check_for_days_with_large_amount_of_missing_values", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>checks dataset for missing values bigger than a specified value\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>maximum_percentage : float\n    value between 0 and 1 as percentage when large amount of missing values is reached\n\ndata : pd.DataFrame\n    data to evaluate\n\nfrequency : str\n    frequency data should have\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>list of days with high share of missing values\n</code></pre>\n", "parameters": ["self", "maximum_percentage", "data", "frequency"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.missing_values_augmentation", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.missing_values_augmentation", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>more advanced missing value fill method using mean profile and random noise (should be used when many values are missing)\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>column : str\n    column to augment data\n\ndrop_data_under_value : float\n    if data lower then threshold data of day will be dropped\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dataset : pd.DataFrame\n    filled dataset\n</code></pre>\n", "parameters": ["self", "column", "drop_data_under_value_of"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.interpolate_data", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.interpolate_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>interpolates missing values by using interpolation (should be used when there are some missing values)\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>columns : list of str\n    name of columns to interpolate\n\ndropna : bool\n    if na values should be dropped\n\nmethod : str\n    method of interpolation\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>dataset : pd.DataFrame\n    filled dataset\n</code></pre>\n", "parameters": ["self", "columns", "dropna", "method"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.rename_column", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.rename_column", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>rename specific column\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>column_name : str\n    column to be renamed\n\nnew_column_name : str\n    new name for column\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "column_name", "new_column_name"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.sort_index", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.sort_index", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>sort the index\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>None\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.seasonal_decomposition", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.seasonal_decomposition", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>decomposes the data into trend, seasonal and residual parts\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>start : datetime or str\n    start date of dataset for investigation\n\nend : datetime or str\n    end date of dataset for investigation\n\nmodel : str\n    additive or multiplicative\n\ncolumn : str\n    which column to use\n\nperiod : int\n    period in data\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>plot\n</code></pre>\n", "parameters": ["self", "start", "end", "model", "column", "period"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.TimeSeriesDataFrame.add_data", "modulename": "timeseriesfunctions", "qualname": "TimeSeriesDataFrame.add_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>add new data to data in the class\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>data : pd.DataFrame\n    data to add\n\ntime_column: str\n    name of time column\n\ntime_data : pd.Series or pd.DataFrame\n    if time_data not in data\n\ntime_is_index : bool\n    if time is index\n\ntimezone : str\n    timezone of time series if not already specified\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>Nothing to return\n</code></pre>\n", "parameters": ["self", "data", "time_column", "time_data", "time_is_index", "timezone"], "funcdef": "def"}, {"fullname": "timeseriesfunctions.test", "modulename": "timeseriesfunctions", "qualname": "test", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "parser", "modulename": "parser", "qualname": "", "type": "module", "doc": "<p>This is an interface to Python's internal parser.</p>\n"}, {"fullname": "parser.compilest", "modulename": "parser", "qualname": "compilest", "type": "function", "doc": "<p>Compiles an ST object into a code object.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "parser.expr", "modulename": "parser", "qualname": "expr", "type": "function", "doc": "<p>Creates an ST object from an expression.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "parser.isexpr", "modulename": "parser", "qualname": "isexpr", "type": "function", "doc": "<p>Determines if an ST object was created from an expression.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "parser.issuite", "modulename": "parser", "qualname": "issuite", "type": "function", "doc": "<p>Determines if an ST object was created from a suite.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "parser.suite", "modulename": "parser", "qualname": "suite", "type": "function", "doc": "<p>Creates an ST object from a suite.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "parser.sequence2st", "modulename": "parser", "qualname": "sequence2st", "type": "function", "doc": "<p>Creates an ST object from a tree representation.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "parser.st2tuple", "modulename": "parser", "qualname": "st2tuple", "type": "function", "doc": "<p>Creates a tuple-tree representation of an ST.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "parser.st2list", "modulename": "parser", "qualname": "st2list", "type": "function", "doc": "<p>Creates a list-tree representation of an ST.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "parser.tuple2st", "modulename": "parser", "qualname": "tuple2st", "type": "function", "doc": "<p>Creates an ST object from a tree representation.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "parser.ParserError", "modulename": "parser", "qualname": "ParserError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "parser.STType", "modulename": "parser", "qualname": "STType", "type": "class", "doc": "<p>Intermediate representation of a Python parse tree.</p>\n"}, {"fullname": "parser.STType.__init__", "modulename": "parser", "qualname": "STType.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "parser.STType.compile", "modulename": "parser", "qualname": "STType.compile", "type": "function", "doc": "<p>Compile this ST object into a code object.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "parser.STType.isexpr", "modulename": "parser", "qualname": "STType.isexpr", "type": "function", "doc": "<p>Determines if this ST object was created from an expression.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "parser.STType.issuite", "modulename": "parser", "qualname": "STType.issuite", "type": "function", "doc": "<p>Determines if this ST object was created from a suite.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "parser.STType.tolist", "modulename": "parser", "qualname": "STType.tolist", "type": "function", "doc": "<p>Creates a list-tree representation of this ST.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "parser.STType.totuple", "modulename": "parser", "qualname": "STType.totuple", "type": "function", "doc": "<p>Creates a tuple-tree representation of this ST.</p>\n", "parameters": ["unknown"], "funcdef": "def"}, {"fullname": "path_utils", "modulename": "path_utils", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "path_utils.config_path_to_full_path", "modulename": "path_utils", "qualname": "config_path_to_full_path", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Get relative path from config and combine them to a full path (especially for Socket Server use)\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>total_path: string\n    combined path\n</code></pre>\n", "parameters": ["folder_path", "section", "name", "check_path_end"], "funcdef": "def"}, {"fullname": "path_utils.check_path_ending", "modulename": "path_utils", "qualname": "check_path_ending", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>check if a '/' is at the end of the path otherwise add\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>path : str/path\n    to check\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>path: str\n    corrected path\n</code></pre>\n", "parameters": ["path"], "funcdef": "def"}, {"fullname": "path_utils.check_path_exist", "modulename": "path_utils", "qualname": "check_path_exist", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>check if given path exists otherwise folder is created\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>path : str/path\n    to check\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>result : bool\n</code></pre>\n", "parameters": ["path"], "funcdef": "def"}, {"fullname": "path_utils.check_file_cache", "modulename": "path_utils", "qualname": "check_file_cache", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Check if cached files are available and return true or false\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>data_cache_path: str\n    path to where data is stored\ndata_cache_name: str\n    name of file where data is stored\n</code></pre>\n\n<p>Return</p>\n\n<pre><code>Bool:\n    if cache file exists\n</code></pre>\n", "parameters": ["data_cache_path", "data_cache_name"], "funcdef": "def"}, {"fullname": "path_utils.time_to_path", "modulename": "path_utils", "qualname": "time_to_path", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Converts a given timestamp to folder path\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>timestamp : pd.datetime\n    timestmap to convert\n\npath_prefix : str\n    string to add before string of time\n\ndata_name_ending : str\n    str to add after string of time\n\ncreate_path : bool\n    if path should be created\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>combined_time_path : str\n    path including time as folder name\n</code></pre>\n", "parameters": ["timestamp", "path_prefix", "data_name_ending", "create_path"], "funcdef": "def"}, {"fullname": "path_utils.path_to_time", "modulename": "path_utils", "qualname": "path_to_time", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Converts path with timestamp to time\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>time_stamp : pd.datetime\n    time extracted from path\n</code></pre>\n", "parameters": ["file", "path", "file_split", "path_split", "timezone"], "funcdef": "def"}, {"fullname": "path_utils.delete_file", "modulename": "path_utils", "qualname": "delete_file", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>deletes exisiting file\n</code></pre>\n\n<p>Parameter</p>\n\n<pre><code>filepath : str\n    path to file to be removed\n</code></pre>\n", "parameters": ["filepath"], "funcdef": "def"}, {"fullname": "weather_data", "modulename": "weather_data", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "weather_data.Weather", "modulename": "weather_data", "qualname": "Weather", "type": "class", "doc": "<p>Function</p>\n\n<pre><code>Weather class combines all functions needed to store, update and preprocess weather data from\nOWM and NASA. This class is a front end to the various underlying function.\n</code></pre>\n\n<p>Principle</p>\n\n<pre><code>Methods are mostly loosely connected and can be used interchangeably. Exception to this is\npreprocess_data which relies on the result of get_historical_data_from_server.\n\nMost methods are downloading data from servers and pre-processing them according to their\nspecial needs. All needed methods are also implemented in WeatherDataManager which also stores\nand loads all data needed for operation.\n</code></pre>\n\n<p>Attributes</p>\n\n<pre><code>dm : class\n    WeatherDataManager which has all data for weather (NASA, OWM) stored and different\n    methods to process\n\ndataset_short_term_forecast : pd.DataFrame\n    collection of all weather data for short-term-prediction\n\ndataset_long_term_forecast : pd.DataFrame\n    collection of Nasa weather data\n</code></pre>\n\n<p>Methods</p>\n\n<pre><code>__init_data-manager()\n    initializes WeatherDataManager-instance and reads in already saved data\n\nget_historic_data_from_server()\n    gets new weather data stored on a server\n\npreprocess_data(url_list)\n    shows missing values and saves data (missing values are not corrected)\n\nget_forecast_data_from_server(url_list)\n    retrieves OWM forecasts from server\n\nget_data_from_nasa(time_now)\n    gets all data from NASA server up to current timestep\n\nset_up_sun_times()\n    getting information when sun rises and sets\n</code></pre>\n"}, {"fullname": "weather_data.Weather.__init__", "modulename": "weather_data", "qualname": "Weather.__init__", "type": "function", "doc": "<p>Attributes</p>\n\n<pre><code>dm : class\n    WeatherDataManager which has all data for weather (NASA, OWM) stored and different\n    methods to process\n\ndataset_short_term_forecast : pd.DataFrame\n    collection of all weather data for short-term-prediction\n\ndataset_long_term_forecast : pd.DataFrame\n    collection of Nasa weather data\n</code></pre>\n", "parameters": ["self", "current_path"], "funcdef": "def"}, {"fullname": "weather_data.Weather.load_all_data", "modulename": "weather_data", "qualname": "Weather.load_all_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Initializes needed functions and data\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>No returns needed as data is stored in WeatherDataManager-class itself\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "weather_data.Weather.get_historic_data_from_server", "modulename": "weather_data", "qualname": "Weather.get_historic_data_from_server", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Collect historical weather data from server, standardizes it and adds it to already cached data\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>url_list: list\n    list of urls to get OWM historical data from\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>No returns needed as data is stored in WeatherDataManager-class itself\n</code></pre>\n", "parameters": ["self", "url_list"], "funcdef": "def"}, {"fullname": "weather_data.Weather.preprocess_data", "modulename": "weather_data", "qualname": "Weather.preprocess_data", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Preprocess historical weather data\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>No returns needed as data is stored in WeatherDataManager-class itself\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "weather_data.Weather.get_forecast_data_from_server", "modulename": "weather_data", "qualname": "Weather.get_forecast_data_from_server", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>Get weather forecast of OWM from server provided currently by INENSUS\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>url_list: list\n    list of urls for OWM weather prediction\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>No returns needed as data is stored in WeatherDataManager-class itself\n</code></pre>\n", "parameters": ["self", "url_list"], "funcdef": "def"}, {"fullname": "weather_data.Weather.get_data_from_nasa", "modulename": "weather_data", "qualname": "Weather.get_data_from_nasa", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>get long term NASA weather data\n</code></pre>\n\n<p>Parameters</p>\n\n<pre><code>time_now : pd.datetime\n    current timestamp format Y-Month-Day H:M\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>No returns needed as data is stored in WeatherDataManager-class itself\n</code></pre>\n", "parameters": ["self", "time_now"], "funcdef": "def"}, {"fullname": "weather_data.Weather.set_up_sun_times", "modulename": "weather_data", "qualname": "Weather.set_up_sun_times", "type": "function", "doc": "<p>Function</p>\n\n<pre><code>get sunset and sunrise infomration\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>No returns needed as data is stored in WeatherDataManager-class itself\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.addField("qualname");
            this.addField("fullname");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();